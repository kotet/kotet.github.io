<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=description content="この記事は Why and when you should use SoA · を自分用に訳したものを 許可を得て 公開するものである。 コードのコメントも一部翻訳されている。 ところどころ訳が怪しいと"><link rel=stylesheet href=https://blog.kotet.jp/sass/single.min.a46209b7292a5337cb1ba441dd38238fbe3cc498d46e0bd08c757deccdc8f28f.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/d.min.js></script><script>hljs.configure({languages:[]})
hljs.initHighlightingOnLoad();</script><script defer src="//cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type=text/javascript></script><script type=text/x-mathjax-config>
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        displayMath: [['$$','$$']],
        processEscapes: true
      }
    });
</script><title>#dlang なぜ、どういう時にSOAを使うべきなのか【翻訳】 - Kotet&#39;s Personal Blog</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel=canonical href=https://blog.kotet.jp/2017/05/soa-d/><link rel=icon href=/favicon.ico><meta name=twitter:card content=summary><meta name=og:title content="#dlang なぜ、どういう時にSOAを使うべきなのか【翻訳】 - Kotet's Personal Blog"><meta name=og:description content="この記事は Why and when you should use SoA · を自分用に訳したものを 許可を得て 公開するものである。 コードのコメントも一部翻訳されている。 ところどころ訳が怪しいと"><meta name=twitter:image content=https://blog.kotet.jp/assets/logo.png><meta name=twitter:url content=https://blog.kotet.jp/2017/05/soa-d/><meta name=twitter:site content=@kotetttt><meta name=twitter:creator content=@kotetttt><meta name=generator content="Hugo 0.52"><script defer src="//www.googletagmanager.com/gtag/js?id=UA-88180620-1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-88180620-1');</script><script async src=//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script><script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"ca-pub-8443812672116269",enable_page_level_ads:true});</script></head><body><header class=site><nav><ul><li><a href=/about>ABOUT</a></li><li><a href=/products>PRODUCTS</a></li><li><a href=/tags>TAGS</a></li><li><a href=/index.xml>FEED</a></li></ul></nav><h1><a href=/>KOTET'S<br>PERSONAL<br>BLOG</a></h1></header><main><header><h2><a href=/tags/dlang>#dlang</a>
なぜ、どういう時にSOAを使うべきなのか【翻訳】</h2><p><time>2017-05-19</time>
<a href=/tags/dlang>#dlang</a> <a href=/tags/tech>#tech</a> <a href=/tags/translation>#translation</a></p><div style="border:.5em solid gold;padding:1em;margin-bottom:1em"><p style=font-weight:700;margin:0>これは1年以上前の記事です</p><p style=margin:0>ここに書かれている情報、見解は現在のものとは異なっている場合があります。</p></div><aside><p>Table of Contents</p><nav id=TableOfContents><ul><li><ul><li><ul><li><a href=#soaとは何か>SoAとは何か?</a></li><li><a href=#なぜsoaは便利なのか>なぜSoAは便利なのか?</a></li><li><a href=#soaは使いにくくないのか>SoAは使いにくくないのか?</a></li><li><a href=#dでのsoaの実装>DでのSoAの実装</a></li><li><a href=#soaを使うときはいつか>SoAを使うときはいつか</a></li><li><a href=#soaは-時期尚早な最適化-ではないのか>SoAは「時期尚早な最適化」ではないのか?</a></li></ul></li></ul></li></ul></nav></aside></header><article><p>この記事は</p><p><a href=https://maikklein.github.io/post/soa-d/>Why and when you should use SoA ·</a></p><p>を自分用に訳したものを
<a href=https://maikklein.github.io/post/soa-d/#comment-3309967000>許可を得て</a>
公開するものである。
コードのコメントも一部翻訳されている。
ところどころ訳が怪しいところがあるので、なにか見つけた人は<a href=https://github.com/kotet/blog.kotet.jp>contribute</a>だ!</p><hr><h3 id=soaとは何か>SoAとは何か?</h3><p>SoAとは単に<code>配列の構造体(Structure of arrays)</code>を意味します。</p><pre><code class=language-d>//AoS: 構造体の配列(Array of structures)
struct Vec2{
    float x;
    float y;
}
Array!Vec2 vectors;
</code></pre><pre><code class=language-d>//SoA: 配列の構造体
struct Vec2{
    float[] x;
    float[] y;
}
</code></pre><h3 id=なぜsoaは便利なのか>なぜSoAは便利なのか?</h3><p><code>クライアント・サーバー・アーキテクチャー</code>で小さな<code>udpゲームサーバー</code>を書くことを想像してみてください。
あなたにはクライアントが接続できるサーバーがあります。
<code>サーバー</code>は現在接続しているクライアントたちを覚えておく必要があります。
サーバーはメッセージを<code>recvfrom</code>でポールし、あなたがudpをよく知らない場合、
<code>recvfrom</code>はソケットにバインドされたポートとアドレスへ送られるパケットを返します。</p><p>パケットが来たとき、最初に知りたいのはパケットが接続しているクライアントから来たかどうかかもしれません。
あなたにはそれをこのように書く傾向があることでしょう:</p><pre><code class=language-cpp>struct Server{
    struct RemoteClient{
        Address address;
        SysTime lastReceivedPacket;
        //more data
    }
    Array!RemoteClient remoteClients;

    void poll(){
        //Address address
        //recvfrom(buffer, address);
    }
}
</code></pre><p>どのクライアントがパッケージを送ったのか知りたい時、正しい<code>remoteClient</code>を探すために単に<code>remoteClients</code>配列を使うことができます。
問題はアドレスフィールドにしか興味がないが、<code>RemoteClient</code>をイテレートする必要があるということです。
これはそれが必要ないとしても、<code>lastReceivedPacket</code>のような他のすべてのデータを不必要にロードしているということを意味します。</p><p>そして実際のアプリケーションで<code>RemoteClient</code>の中にどれくらいのデータがありうるか知りたいなら、
こちらが<a href=https://github.com/lsalzman/enet/blob/master/include/enet/enet.h#L258>Enet Peer</a>の構造体です。
これは<code>Peer</code>であり<code>RemoteClient</code>ではないためフェアな比較ではないかもしれませんが、
これはデータがかなり大きくなるかもしれないということを示しています。</p><pre><code class=language-c>typedef struct _ENetPeer
{ 
   ENetListNode  dispatchList;
   struct _ENetHost * host;
   enet_uint16   outgoingPeerID;
   enet_uint16   incomingPeerID;
   enet_uint32   connectID;
   enet_uint8    outgoingSessionID;
   enet_uint8    incomingSessionID;
   ENetAddress   address;            /**&lt; Internet address of the peer */
   void *        data;               /**&lt; Application private data, may be freely modified */
   ENetPeerState state;
   ENetChannel * channels;
   size_t        channelCount;       /**&lt; Number of channels allocated for communication with peer */
   enet_uint32   incomingBandwidth;  /**&lt; Downstream bandwidth of the client in bytes/second */
   enet_uint32   outgoingBandwidth;  /**&lt; Upstream bandwidth of the client in bytes/second */
   enet_uint32   incomingBandwidthThrottleEpoch;
   enet_uint32   outgoingBandwidthThrottleEpoch;
   enet_uint32   incomingDataTotal;
   enet_uint32   outgoingDataTotal;
   enet_uint32   lastSendTime;
   enet_uint32   lastReceiveTime;
   enet_uint32   nextTimeout;
   enet_uint32   earliestTimeout;
   enet_uint32   packetLossEpoch;
   enet_uint32   packetsSent;
   enet_uint32   packetsLost;
   enet_uint32   packetLoss;          /**&lt; mean packet loss of reliable packets as a ratio with respect to the constant ENET_PEER_PACKET_LOSS_SCALE */
   enet_uint32   packetLossVariance;
   enet_uint32   packetThrottle;
   enet_uint32   packetThrottleLimit;
   enet_uint32   packetThrottleCounter;
   enet_uint32   packetThrottleEpoch;
   enet_uint32   packetThrottleAcceleration;
   enet_uint32   packetThrottleDeceleration;
   enet_uint32   packetThrottleInterval;
   enet_uint32   pingInterval;
   enet_uint32   timeoutLimit;
   enet_uint32   timeoutMinimum;
   enet_uint32   timeoutMaximum;
   enet_uint32   lastRoundTripTime;
   enet_uint32   lowestRoundTripTime;
   enet_uint32   lastRoundTripTimeVariance;
   enet_uint32   highestRoundTripTimeVariance;
   enet_uint32   roundTripTime;
   enet_uint32   roundTripTimeVariance;
   enet_uint32   mtu;
   enet_uint32   windowSize;
   enet_uint32   reliableDataInTransit;
   enet_uint16   outgoingReliableSequenceNumber;
   ENetList      acknowledgements;
   ENetList      sentReliableCommands;
   ENetList      sentUnreliableCommands;
   ENetList      outgoingReliableCommands;
   ENetList      outgoingUnreliableCommands;
   ENetList      dispatchedCommands;
   int           needsDispatch;
   enet_uint16   incomingUnsequencedGroup;
   enet_uint16   outgoingUnsequencedGroup;
   enet_uint32   unsequencedWindow [ENET_PEER_UNSEQUENCED_WINDOW_SIZE / 32]; 
   enet_uint32   eventData;
   size_t        totalWaitingData;
} ENetPeer;
</code></pre><p>では<code>SoA</code>ではどのようになるか見てみましょう。</p><pre><code class=language-cpp>struct Server{
    struct RemoteClients{
        size_t length;
        Address[] address;
        SysTime[] lastReceivedPacket;
        //more data
    }
    RemoteClients remoteClients;

    void poll(){
        //Address address
        //recvfrom(buffer, address);
    }
}
</code></pre><p>すべての<code>remoteClients.address</code>のアドレスにアクセスでき、不必要なデータをキャッシュにロードする必要はありません。</p><h3 id=soaは使いにくくないのか>SoAは使いにくくないのか?</h3><p>多くの言語ではそのとおりです。</p><pre><code class=language-cpp>struct RemoteClients{
    size_t length;
    Address[] address;
    SysTime[] lastReceivedPacket;
    //more data
}
</code></pre><p>配列を割り当て、それが動的配列の場合は拡張しなければならないために定義は単純化されています。
要素の挿入と削除についても気にかける必要もあります、
<code>lastReceivedPacket</code>を追加せずにアドレスだけを<code>RemoteClients</code>に追加するようなことがあってはいけません。
データはゆるく対になっているためです。
以前の<code>AoS</code>の時は<code>RemoteClient</code>に<code>remoteClients[index]</code>でアクセスできましたが、
今は<code>RemoteClient</code>にその要素<code>remoteClients.addresses[index]</code>や<code>remoteClients.lastReceivedPacket[index]</code>でアクセスします。</p><h3 id=dでのsoaの実装>DでのSoAの実装</h3><p>まずデモンストレーションから始めましょう。</p><pre><code class=language-d>struct Vec2{
    float x;
    float y;
}
auto s = SOA!(Vec2)();

s.insertBack(1.0f, 2.0f);
s.insertBack(Vec2(1.0, 2.0f));
writeln(s.x); // [1, 1]
writeln(s.y); // [2, 2]
</code></pre><p>データで構造体を作ることができ、<code>SOA</code>は構造体をみて内部的に適切な配列を作ります。
持っているフィールドと同じ数の配列があるため、<code>insertBack</code>はちょっと普通の配列と異なります。
これは<code>insertBack</code>が可変長である必要があることを意味します。
<code>insertBack</code>はかわりにそれ自身の構造体も受け入れます。</p><p><strong>以下のコードは実際に使うことを意図して書かれたコードではなく、単なる概念実証です。</strong></p><pre><code class=language-d>struct SOA(T){
    import std.experimental.allocator;
    import std.experimental.allocator.mallocator;

    import std.meta: staticMap;
    import std.typecons: Tuple;
    import std.traits: FieldNameTuple;

    alias toArray(T) = T[];
    alias toType(string s) = typeof(__traits(getMember, T, s));

    alias MemberNames = FieldNameTuple!T;
    alias Types = staticMap!(toType, MemberNames);
    alias ArrayTypes = staticMap!(toArray, Types);

    this(size_t _size, IAllocator _alloc = allocatorObject(Mallocator.instance)){
        alloc = _alloc;
        size = _size;
        allocate(size);
    }

    ref auto opDispatch(string name)(){
        import std.meta: staticIndexOf;
        alias index = staticIndexOf!(name, MemberNames);
        static assert(index &gt;= 0);
        return containers[index];
    }

    void insertBack(Types types){
        if(length == size) grow;
        foreach(index, ref container; containers){
            container[length] = types[index];
        }
        length = length + 1;
    }

    void insertBack(T t){
        if(length == size) grow;
        foreach(index, _; Types){
            containers[index][length] = __traits(getMember, t, MemberNames[index]);
        }
        length = length + 1;
    }

    size_t length() const @property{
        return _length;
    }

    ~this(){
        if(alloc is null) return;
        foreach(ref container; containers){
            alloc.dispose(container);
        }
    }

private:
    void length(size_t len)@property{
        _length = len;
    }

    Tuple!ArrayTypes containers;
    IAllocator alloc;

    size_t _length = 0;
    size_t size = 0;
    short growFactor = 2;

    void allocate(size_t size){
        if(alloc is null){
            alloc = allocatorObject(Mallocator.instance);
        }
        foreach(index, ref container; containers){
            container = alloc.makeArray!(Types[index])(size);
        }
    }

    void grow(){
        import std.algorithm: max;
        size_t newSize = max(1,size * growFactor);
        size_t expandSize = newSize - size;

        if(size is 0){
            allocate(newSize);
        }
        else{
            foreach(ref container; containers){
                alloc.expandArray(container, expandSize);
            }
        }
        size = newSize;
    }
}
</code></pre><pre><code class=language-d>alias toArray(T) = T[];
alias toType(string s) = typeof(__traits(getMember, T, s));

alias MemberNames = FieldNameTuple!T;
alias Types = staticMap!(toType, MemberNames);
alias ArrayTypes = staticMap!(toArray, Types);
</code></pre><p><code>MemberNames</code>は単なるフィールドの名前群です。
たとえば<code>構造体 Vec2{float x; float y}</code>は型<code>AliasSeq!(&quot;x&quot;, &quot;y&quot;)</code>になります。
<code>toType</code>はメンバ名をとり実際の型にします。
例として上の<code>toType!(&quot;x&quot;)</code>は型<code>float</code>を返します。</p><p><code>staticMap</code>の助けを得てメンバ名を実際の型に変換することができます。
たとえば上の<code>AliasSeq!(&quot;x&quot;, &quot;y&quot;)</code>は<code>AliasSeq!(float, float)</code>に変わります。</p><p>もうすぐ型を配列に変換する必要が出てきます。
<code>AliasSeq!(float, float)</code>を<code>AliasSeq!(float[], float[])</code>にです。
それを<code>toArray</code>と<code>staticMap</code>でします。</p><p>その後配列のタプルを作ることができます。</p><pre><code class=language-d>Tuple!ArrayTypes containers;
</code></pre><p>要素の挿入はかなり簡単です。</p><pre><code class=language-d>void insertBack()(Types types){
    if(length == size) grow;
    foreach(index, ref container; containers){
        container[length] = types[index];
    }
    length = length + 1;
}
</code></pre><p><code>insertBack</code>が受け入れるべき型はすでにわかっています。
構造体のフィールド郡の型をうけいれるべきです。
そして配列のタプルである<code>containers</code>をコンパイル時にイテレートします。</p><p>それから適切な<code>argument</code>に<code>types[index]</code>でアクセスし、それを配列に挿入するだけです。</p><p>構造体そのものを挿入することもできます。</p><pre><code class=language-d>void insertBack(T t){
    if(length == size) grow;
    foreach(index, _; Types){
        containers[index][length] = __traits(getMember, t, MemberNames[index]);
    }
    length = length + 1;
}
</code></pre><p><code>index</code>を取得するために型をイテレートします。
<code>index</code>を適切なコンテナを得るためと、構造体の適切なフィールド名を見つけるために使います。
順序は常に同じためこれは動作します。</p><p>上のコードを<code>Vec2</code>ようにするとだいたいこんなふうになります。</p><pre><code class=language-d>void insertBack(Vec2 t){
    if(length == size) grow;
    containers[0][length] = t.x;
    containers[1][length] = t.y;
    length = length + 1;
}
</code></pre><p>配列にフィールド名でアクセスできます。
Dでこれは<code>opDispatch</code>によって非常に簡単にできます。</p><pre><code class=language-d>ref auto opDispatch(string name)(){
    import std.meta: staticIndexOf;
    alias index = staticIndexOf!(name, MemberNames);
    static assert(index &gt;= 0);
    return containers[index];
}
</code></pre><p>上のサンプルを<code>Vec2</code>用にした場合ではすべてのxの配列を<code>s.x</code>、すべてのyの配列を<code>s.y</code>で得ることができます。
<code>s.x</code>を呼んだ場合<code>opDispatch</code>はコンパイル時にこんな感じになります。</p><pre><code class=language-d>ref auto opDispatch(){
    import std.meta: staticIndexOf;
    alias index = staticIndexOf!(&quot;x&quot;, MemberNames);
    static assert(index &gt;= 0);
    return containers[index];
}
</code></pre><p><code>MemberNames opDispatch</code>内が失敗しなかった場合、<code>opDispatch name</code>のインデックスを<code>MemberNames</code>から取得します。
<code>MemberNames</code>内にあればそのインデックスで適切なコンテナにアクセスします。</p><pre><code class=language-d>struct Server{
    struct RemoteClients{
        Address address;
        SysTime lastReceivedPacket;
        //more data
    }
    SOA!RemoteClient remoteClients;

    void poll(){
        //Address address
        //recvfrom(buffer, address);
    }
}
</code></pre><h3 id=soaを使うときはいつか>SoAを使うときはいつか</h3><p>まず第一に<code>SoA</code>は銀の弾丸ではなく、あなたのコードベースのすべての<code>AoS</code>を<code>SoA</code>に置き換えるべきというわけではありません。</p><p><code>SoA</code>に意味があるのはこのような時です:</p><ul><li>データを1つの配列に保持したくなるとわかっているとき</li><li>部分的にデータにアクセスしたいとき</li></ul><p>しかし時にはデータのすべてのコンポーネントにアクセスしたい時もあるでしょう。
例としてベクトルが挙げられます。</p><pre><code class=language-d>struct Vec3{
    float x;
    float y;
    float z;
}
</code></pre><p>加算、減算、ドット積、距離その他いろいろのほとんどの操作はすべてのコンポーネントを使うでしょう。
たとえ最終的に</p><pre><code class=language-d>struct Vec3{
    float x;
    float y;
    float z;
}

Array!Vec3 positions;

positions[].filter!(v =&gt; v.x &lt; 10.0f);
</code></pre><p><code>x コンポーネント</code>が<code>10.0f</code>より小さいすべてのベクトルをフィルタしたくなっても、2つのfloatが余分に読み込まれるだけです。
<code>Vec3</code>は大きくならず、これ以外の他のデータ構造が成長し、将来のボトルネックになるかもしれません。</p><h3 id=soaは-時期尚早な最適化-ではないのか>SoAは「時期尚早な最適化」ではないのか?</h3><p>私の意見は違います。
<code>AoS</code>の問題は、それが将来パフォーマンスボトルネックになった場合、多くのコードをリファクタしなければならないというところです。
たとえばあなたはこのように構造体hotとcoldにデータをパックするかもしれません:</p><pre><code class=language-d>struct Bar{
    struct Hot{
        Data1 d1;
        Data2 d2;
        ...
    }
    struct Cold{
        Data3 d3;
        Data4 d4;
        ...
    }

    Hot* hot;
    Cold* cold;
}
</code></pre><p>しかし言語によってはまだまだ多くのコードをリファクタしなければならないかもしれません。
早い段階でデータアクセスについて考えることで手間が省けるかもしれません。</p><p><a href="https://www.youtube.com/watch?v=ZHqFrNyLlpA">Jonathan Blow</a>には名無し変数とSoAをカバーする言語デモンストレーションがあります。
Quick note:Jonathan BlowのやりかたはDの<code>alias this</code>とよく似ています。</p><p>使う言語によっては、<code>SoA</code>は<code>AoS</code>と比べてそんなに悪くはありません。</p><pre><code class=language-d>//AoS
remoteClients[index].address;

//vs 

//SoA
remoteClients.address[index];
</code></pre><p>しかし<code>SoA</code>はキャッシュからの関係ない不必要なローディングなしにデータに部分的なアクセスができるため、よりスケールします。</p></article><footer><h2><a href=/tags/dlang>#dlang</a>
なぜ、どういう時にSOAを使うべきなのか【翻訳】</h2><p><time>2017-05-19</time>
<a href=/tags/dlang>#dlang</a> <a href=/tags/tech>#tech</a> <a href=/tags/translation>#translation</a></p></footer><div class=ad-wrapper><ins class=adsbygoogle style=display:block data-ad-client=ca-pub-8443812672116269 data-ad-slot=2914874272 data-ad-format=horizontal data-full-width-responsive=true></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div></main><footer class=site></footer></body></html>