<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=description content="2次元上の2点間の距離を求めたいとしましょう、ただし点は古いテレビゲームのような“ラップアラウンド”の世界にあります – スクリーンの上下左右から出ると、反対側から現れるのです。"><link rel=stylesheet href=https://blog.kotet.jp/sass/single.min.c9d013014574db8d6be4e1768e32dd541f3431f611fecfcb824fed9a19b8fdd3.css><script defer src="//cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type=text/x-mathjax-config>
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        displayMath: [['$$','$$'], ['\[','\]']],
        processEscapes: true
      }
    });
</script><title>#tech 「ラップアラウンド」（トロイダル）な空間における2点間の距離の計算【翻訳】 - Kotet&#39;s Personal Blog</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel=canonical href=https://blog.kotet.jp/2017/10/calculating-the-distance-between-points-in-wrap-around-toroidal-space/><link rel=icon href=/favicon.ico><meta name=twitter:card content=summary><meta name=og:title content="#tech 「ラップアラウンド」（トロイダル）な空間における2点間の距離の計算【翻訳】 - Kotet's Personal Blog"><meta name=og:description content="2次元上の2点間の距離を求めたいとしましょう、ただし点は古いテレビゲームのような“ラップアラウンド”の世界にあります – スクリーンの上下左右から出ると、反対側から現れるのです。"><meta name=og:image content=https://blog.kotet.jp2017/10/04/wraparound.png><meta name=twitter:url content=https://blog.kotet.jp/2017/10/calculating-the-distance-between-points-in-wrap-around-toroidal-space/><meta name=twitter:site content=@kotetttt><meta name=twitter:creator content=@kotetttt><meta name=generator content="Hugo 0.48"><script defer src="//www.googletagmanager.com/gtag/js?id=UA-88180620-1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-88180620-1');</script><script async src=//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script><script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"ca-pub-8443812672116269",enable_page_level_ads:true});</script></head><body><header class=site><nav><ul><li><a href=/about>ABOUT</a></li><li><a href=/products>PRODUCTS</a></li><li><a href=/tags>TAGS</a></li><li><a href=/index.xml>FEED</a></li></ul></nav><h1><a href=/>KOTET'S PERSONAL BLOG</a></h1></header><main><header><h2><a href=/tags/tech>#tech</a>
「ラップアラウンド」（トロイダル）な空間における2点間の距離の計算【翻訳】</h2><p><time>2017-10-04</time>
<a href=/tags/tech>#tech</a> <a href=/tags/translation>#translation</a></p><aside><p>Table of Contents</p></aside></header><article><p>この記事は、
<a href=https://blog.demofox.org/2017/10/01/calculating-the-distance-between-points-in-wrap-around-toroidal-space/>Calculating the Distance Between Points in “Wrap Around” (Toroidal) Space</a>
を自分用に翻訳したものを
<a href=https://blog.demofox.org/2017/10/01/calculating-the-distance-between-points-in-wrap-around-toroidal-space/#comment-526>許可を得て</a>
公開するものである。</p><p>ソース中にコメントの形で原文を残している。
誤字や誤訳などを見つけたら今すぐ
<a href=https://github.com/kotet/blog.kotet.jp>Pull request</a>だ!</p><hr><p>2次元上の2点間の距離を求めたいとしましょう、ただし点は古いテレビゲームのような“ラップアラウンド”の世界にあります – スクリーンの上下左右から出ると、反対側から現れるのです。</p><p><img src=/assets/2017/10/04/wraparound.png alt="https://demofox2.files.wordpress.com/2017/09/wraparound.png?w=800"></p><p>この世界は、ドーナツとしても知られるトロイドのような形をしています。
空洞のドーナツの面にいることを想像すると、ちょうど同じ振る舞いをするでしょう。
あなたが“下“に行くと、先ほど”上“だと考えていたところに着きます。
あなたが“上“に行くと、先ほど”下“だと考えていたところに着きます。</p><p>このような世界で、どのように2点間の距離を求めればいいのでしょうか？</p><p>下の状況で赤い地点と緑の地点の距離を求めようとしているとしましょう:</p><p><img src=/assets/2017/10/04/wraparound2.png alt="https://demofox2.files.wordpress.com/2017/09/wraparound2.png?w=800"></p><p>1つの方法として、点を1つ選んで(今回は赤にします)、下のようにセルを囲むよう8回クローンする、というのがあります。
緑の点からの距離を9つの赤い点でそれぞれ計算し、最も小さいものが答えになります。</p><p><img src=/assets/2017/10/04/wraparound3.png alt="https://demofox2.files.wordpress.com/2017/10/wraparound3.png?w=800"></p><p>最短距離を計算するために9回の計算をするというのは望ましいものではありません。
平方根の計算を避けるために距離の二乗を用いて計算することができますが、効果は微々たるものです。</p><p>次元が上がるとより悪いことになります。
3次元では最短距離を求めるのに27回の距離計算が必要になり、4次元では距離計算は81回になります！</p><p>幸運にもよりよい方法があります。</p><p>世界(画像)の大きさが1単位だと(言い換えると、テクスチャUVを扱っていると)しましょう。
画像の赤い点の9つのコピーを見ると、それらは各座標軸に -1、+0、+1 を足した9つの組み合わせであることがわかります。
-1、+0、+1 をx、y座標に足す全ての可能な組み合わせが赤い点の正しい座標になります。</p><p>距離の公式を見ると、各座標軸の値を別々に最小化すれば、それが全体で最小距離にもなることがわかります。</p><p>\( d = \sqrt{(x_2-x_1)^2+(y_2-y_1)^2} \)</p><p>よって、各座標を別々に最小化するのがより良い方法です。</p><p>x座標から1を引いた、そのままにした、足したときに赤と緑の点のx座標の距離が最小になるなら、それが求めるx座標です。</p><p>x座標の1次元距離が最小の赤い点のx座標が目的の位置になります。</p><p>y座標でも同じように目的の位置を探します(さらに高次元の他の座標軸でも同様にします)。</p><p>これがラップアラウンド空間の点の距離を得るために距離公式に当てはめる点になります。</p><p>実はさらに良くできます。</p><p>各座標軸を別々に処理するため、2点間の1次元距離の絶対値を計算できます。
距離が0.5より大きい場合、その座標の実際の距離は 1 - 距離 です。</p><p>直感的に、1次元の繰り返し空間にいる場合、AからBへの道のりが半分より長いなら間違った道を進んでいるということであり、もう一方の道の方が短いということになります。
もう一方の道の距離は、ある点からそこに戻ってくるまでの距離が1であるため、1から先ほど計算した距離を差し引いたものです！</p><p>以上を各軸に対して行い、実際の距離を得るために距離公式でそれらの1次元距離を使います。</p><p>これによりどの組み合わせが最も近い点かを明示的に把握することなく距離を最小化できます。</p><p>さらに重要なことに、トロイダル空間(ドーナツ空間)における2点間の距離を効率的に計算することができます！</p><p>計算量は非常に改善されます。
次元の数に対して\(O(3^N)\)だったものが線形\(O(N)\)になります。</p><p>こちらが2次元で動作するC++の例です。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>float</span> <span style=color:#a6e22e>ToroidalDistance</span> (<span style=color:#66d9ef>float</span> x1, <span style=color:#66d9ef>float</span> y1, <span style=color:#66d9ef>float</span> x2, <span style=color:#66d9ef>float</span> y2)
{
    <span style=color:#66d9ef>float</span> dx <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>abs(x2 <span style=color:#f92672>-</span> x1);
    <span style=color:#66d9ef>float</span> dy <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>abs(y2 <span style=color:#f92672>-</span> y1);
 
    <span style=color:#66d9ef>if</span> (dx <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0.5f</span>)
        dx <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.0f</span> <span style=color:#f92672>-</span> dx;
 
    <span style=color:#66d9ef>if</span> (dy <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0.5f</span>)
        dy <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.0f</span> <span style=color:#f92672>-</span> dy;
 
    <span style=color:#66d9ef>return</span> std<span style=color:#f92672>::</span>sqrt(dx<span style=color:#f92672>*</span>dx <span style=color:#f92672>+</span> dy<span style=color:#f92672>*</span>dy);
}
</code></pre></div><p>私はタイル状に並べられるテクスチャを作るときにこの問題を思いつきました。
私はタイル状に並べても円が他の円と近づきすぎないように円を配置する必要がありました。</p><p>上記の計算から点の距離を計算するための基礎的なツールが得られました。
点のトロイダルな距離から円の半径を引いて、それぞれが近づきすぎないようにしました。</p><p>そうして、タイル状に並べても距離の制約を維持し続ける画像ができました。</p><p>こちらが画像の例です:</p><p><img src=/assets/2017/10/04/single2.png alt="https://demofox2.files.wordpress.com/2017/10/single2.png?w=800"></p><p>こちらは並べたものです:</p><p><img src=/assets/2017/10/04/tiled2.png alt="https://demofox2.files.wordpress.com/2017/10/tiled2.png?w=800"></p></article><footer><h2><a href=/tags/tech>#tech</a>
「ラップアラウンド」（トロイダル）な空間における2点間の距離の計算【翻訳】</h2><p><time>2017-10-04</time>
<a href=/tags/tech>#tech</a> <a href=/tags/translation>#translation</a></p></footer><div class=ad-wrapper><ins class=adsbygoogle style=display:block data-ad-client=ca-pub-8443812672116269 data-ad-slot=2914874272 data-ad-format=horizontal data-full-width-responsive=true></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div></main><footer class=site></footer></body></html>