<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=description content="先日大学でクワイン・マクラスキー法(Quine-McCluskey algorithm)を習った。 簡単にプログラムに落とし込めそうでテンション"><link rel=stylesheet href=https://blog.kotet.jp/sass/single.min.02c91f0bdf54d569f6c715f0a345bf32b55cd4d3ac11e0b98fec7ad1e614c151.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/d.min.js></script><script>hljs.configure({languages:[]})
hljs.initHighlightingOnLoad();</script><script defer src="//cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type=text/javascript></script><script type=text/x-mathjax-config>
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        displayMath: [['$$','$$']],
        processEscapes: true
      }
    });
</script><title>#dlang Dで書くクワイン・マクラスキー法 - Kotet&#39;s Personal Blog</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel=canonical href=https://blog.kotet.jp/2018/07/quine-mccluskey-d/><link rel=icon href=/favicon.ico><meta name=twitter:card content=summary><meta name=og:title content="#dlang Dで書くクワイン・マクラスキー法 - Kotet's Personal Blog"><meta name=og:description content="先日大学でクワイン・マクラスキー法(Quine-McCluskey algorithm)を習った。 簡単にプログラムに落とし込めそうでテンション"><meta name=twitter:image content=https://blog.kotet.jp/img/common/logo.png><meta name=twitter:url content=https://blog.kotet.jp/2018/07/quine-mccluskey-d/><meta name=twitter:site content=@kotetttt><meta name=twitter:creator content=@kotetttt><meta name=generator content="Hugo 0.55.2"><script defer src="//www.googletagmanager.com/gtag/js?id=UA-88180620-1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-88180620-1');</script><script async src=//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script><script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"ca-pub-8443812672116269",enable_page_level_ads:true});</script></head><body><header class=site><nav><ul><li><span class=text-up>ABOUT</span><a href=/about title=about><svg width="22" height="22" viewBox="0 0 22 22" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><desc>Created with Sketch.</desc><defs/><g id="export" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="info" transform="translate(-1.000000, -1.000000)"><path id="placeholder" fill-opacity="0" fill="#fff" d="M0 0h24v24H0z"/><path d="M12 23C5.92486775 23 1 18.0751322 1 12 1 5.92486775 5.92486775 1 12 1 18.0751322 1 23 5.92486775 23 12 23 18.0751322 18.0751322 23 12 23zm0-2C16.9705627 21 21 16.9705627 21 12 21 7.02943725 16.9705627 3 12 3 7.02943725 3 3 7.02943725 3 12 3 16.9705627 7.02943725 21 12 21zM13.0036109 13.9983464H14.0029544v2h-4v-2h1v-2h-1V9.99834639h3.0006565V13.9983464zM12.0003283 8.99834639C11.4478622 8.99834639 11 8.55063114 11 7.99834639 11 7.44606164 11.4478622 6.99834639 12.0003283 6.99834639 12.5527943 6.99834639 13.0006565 7.44606164 13.0006565 7.99834639c0 .5522847500000001-.44786219999999943 1-1.0003282000000002 1z" id="Oval-17" fill="#000" fill-rule="nonzero"/></g></g></svg></a></li><li><span class=text-bottom>DOWNLOAD</span><a href=/products title=download><svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><desc>Created with Sketch.</desc><defs/><g id="export" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="download" transform="translate(-2.000000, -2.000000)"><path id="placeholder" fill-opacity="0" fill="#fff" d="M0 0h24v24H0z"/><path d="M22 16v4C22 21.1045695 21.1045695 22 20 22H4C2.8954305 22 2 21.1045695 2 20V16H4v4H20V16h2zm-9-3.4142136L16.2928932 9.29289322 17.7071068 10.7071068 12 16.4142136 6.29289322 10.7071068 7.70710678 9.29289322 11 12.5857864V2h2V12.5857864z" id="Combined-Shape" fill="#000"/></g></g></svg></a></li><li><span class=text-up>TAG</span><a href=/tags title=tag><svg width="22" height="14" viewBox="0 0 22 14" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><desc>Created with Sketch.</desc><defs/><g id="export" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="tag" transform="translate(-1.000000, -5.000000)"><path id="placeholder" fill-opacity="0" fill="#fff" d="M0 0h24v24H0z"/><path d="M6.53518376 5H21C22.1045695 5 23 5.8954305 23 7V17C23 18.1045695 22.1045695 19 21 19H6.53518376C5.86647738 19 5.24201473 18.6657977 4.87108317 18.1094004L1.16794971 12.5547002C.944016765 12.2188008.944016765 11.7811992 1.16794971 11.4452998L4.87108317 5.89059961C5.24201473 5.33420227 5.86647738 5 6.53518376 5zM3.20185043 12l3.33333333 5H21V7H6.53518376L3.20185043 12zM7 13C6.44771525 13 6 12.5522847 6 12 6 11.4477153 6.44771525 11 7 11 7.55228475 11 8 11.4477153 8 12 8 12.5522847 7.55228475 13 7 13z" id="Rectangle-29" fill="#000" fill-rule="nonzero"/></g></g></svg></a></li><li><span class=text-bottom>PODCAST</span><a href=https://podcast.kotet.jp title=podcast><svg width="22" height="20" viewBox="0 0 22 20" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><desc>Created with Sketch.</desc><defs/><g id="export" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="broadcasting" transform="translate(-1.000000, -2.000000)"><path id="placeholder" fill-opacity="0" fill="#fff" d="M0 0h24v24H0z"/><path d="M9.38742589 20 8.72075922 22H6.61257411L9.89881747 12.1412699C9.34410225 11.5968755 9 10.8386225 9 10 9 8.34314575 10.3431458 7 12 7 13.6568542 7 15 8.34314575 15 10 15 10.8386225 14.6558977 11.5968755 14.1011825 12.1412699L17.3874259 22H15.2792408L14.6125741 20H9.38742589zM10.7207592 16 10.0540926 18H13.9459074L13.2792408 16H10.7207592zM11.3874259 14H12.6125741L12.2750928 12.987556C12.1844984 12.9957918 12.0927406 13 12 13 11.9072594 13 11.8155016 12.9957918 11.7249072 12.987556L11.3874259 14zM12 11C12.5522847 11 13 10.5522847 13 10 13 9.44771525 12.5522847 9 12 9 11.4477153 9 11 9.44771525 11 10 11 10.5522847 11.4477153 11 12 11zm8.108743-8.43301443C21.9041909 4.52460368 23 7.13433188 23 10 23 12.8656681 21.9041909 15.4753963 20.108743 17.4330144L18.6344261 16.0815573C20.103429 14.4798697 21 12.3446376 21 10 21 7.65536245 20.103429 5.52013028 18.6344261 3.91844274L20.108743 2.56698557zM17.1601092 5.26989991C18.302667 6.51565689 19 8.17639301 19 10 19 11.823607 18.302667 13.4843431 17.1601092 14.7301001L15.6857923 13.3786429C16.501905 12.4888165 17 11.3025764 17 10 17 8.69742358 16.501905 7.51118349 15.6857923 6.62135708L17.1601092 5.26989991zM3.89125699 2.56665655 5.3655739 3.91811372C3.89657104 5.51980126 3 7.65503343 3 9.99967098 3 12.3443085 3.89657104 14.4795407 5.3655739 16.0812282L3.89125699 17.4326854C2.09580905 15.4750673 1 12.8653391 1 9.99967098 1 7.13400286 2.09580905 4.52427466 3.89125699 2.56665655zM6.83989081 5.26957089 8.31420772 6.62102806C7.49809502 7.51085447 7 8.69709456 7 9.99967098 7 11.3022474 7.49809502 12.4884875 8.31420772 13.3783139L6.83989081 14.7297711C5.69733303 13.4840141 5 11.823278 5 9.99967098 5 8.17606399 5.69733303 6.51532787 6.83989081 5.26957089z" id="Combined-Shape" fill="#000" fill-rule="nonzero"/></g></g></svg></a></li><li><span class=text-up>FEED</span><a href=/index.xml title=feed><svg width="22" height="18" viewBox="6 8 .5 10" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><desc>Created with Sketch.</desc><defs><path d="M1 21V19C2.1045695 19 3 19.8954305 3 21H1zm6 0H5C5 18.790861 3.209139 17 1 17V15C4.3137085 15 7 17.6862915 7 21zm4 0H9C9 16.581722 5.418278 13 1 13V11C6.5228475 11 11 15.4771525 11 21z" id="path-1"/></defs><g id="export" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="cast" transform="translate(-1.000000, -3.000000)"><path id="placeholder" fill-opacity="0" fill="#fff" d="M0 0h24v24H0z"/><mask id="mask-2" fill="#fff"><use xlink:href="#path-1"/></mask><use id="Combined-Shape" fill="#000" fill-rule="nonzero" xlink:href="#path-1"/></g></g></svg></a></li></ul></nav><h1><a href=/>KOTET'S<br>PERSONAL<br>BLOG</a></h1></header><main><header><h2><a href=/tags/dlang>#dlang</a>
Dで書くクワイン・マクラスキー法</h2><p><time>2018-07-01</time>
<a href=/tags/dlang>#dlang</a> <a href=/tags/tech>#tech</a> <a href=/tags/log>#log</a></p><aside><p>Table of Contents</p><nav id=TableOfContents><ul><li><ul><li><ul><li><a href=#論理式の簡単化>論理式の簡単化</a></li><li><a href=#クワイン-マクラスキー法>クワイン・マクラスキー法</a><ul><li><a href=#入出力の定義>入出力の定義</a></li><li><a href=#ハミング重み-ハミング距離-項のマージ>ハミング重み、ハミング距離、項のマージ</a></li><li><a href=#主項をみつける>主項をみつける</a></li><li><a href=#最簡形を求める>最簡形を求める</a></li><li><a href=#完成>完成</a></li></ul></li><li><a href=#できたもの>できたもの</a></li><li><a href=#参考文献>参考文献</a></li></ul></li></ul></li></ul></nav></aside></header><article><p>先日大学でクワイン・マクラスキー法(Quine-McCluskey algorithm)を習った。
簡単にプログラムに落とし込めそうでテンションが上がり、実際に書いてみることにした。
理解しようとググったときに、スライドのPDFとか、
ほぼコードをのせただけみたいな記事が多くて困ったので、解説も含めて記事にする。</p><h3 id=論理式の簡単化>論理式の簡単化</h3><p>まずここにWikipediaの
<a href=https://ja.wikipedia.org/wiki/%E3%82%AF%E3%83%AF%E3%82%A4%E3%83%B3%E3%83%BB%E3%83%9E%E3%82%AF%E3%83%A9%E3%82%B9%E3%82%AD%E3%83%BC%E6%B3%95>クワイン・マクラスキー法</a>
のページから持ってきたブール関数\(f\)の真理値表がある。
ここで\(x\)はDon&rsquo;t care、つまり結果がどうなってもいいということを意味する。</p><table><thead><tr><th align=center></th><th align=center>A</th><th align=center>B</th><th align=center>C</th><th align=center>D</th><th align=center>f</th></tr></thead><tbody><tr><td align=center>m0</td><td align=center>0</td><td align=center>0</td><td align=center>0</td><td align=center>0</td><td align=center>0</td></tr><tr><td align=center>m1</td><td align=center>0</td><td align=center>0</td><td align=center>0</td><td align=center>1</td><td align=center>0</td></tr><tr><td align=center>m2</td><td align=center>0</td><td align=center>0</td><td align=center>1</td><td align=center>0</td><td align=center>0</td></tr><tr><td align=center>m3</td><td align=center>0</td><td align=center>0</td><td align=center>1</td><td align=center>1</td><td align=center>0</td></tr><tr><td align=center>m4</td><td align=center>0</td><td align=center>1</td><td align=center>0</td><td align=center>0</td><td align=center>1</td></tr><tr><td align=center>m5</td><td align=center>0</td><td align=center>1</td><td align=center>0</td><td align=center>1</td><td align=center>0</td></tr><tr><td align=center>m6</td><td align=center>0</td><td align=center>1</td><td align=center>1</td><td align=center>0</td><td align=center>0</td></tr><tr><td align=center>m7</td><td align=center>0</td><td align=center>1</td><td align=center>1</td><td align=center>1</td><td align=center>0</td></tr><tr><td align=center>m8</td><td align=center>1</td><td align=center>0</td><td align=center>0</td><td align=center>0</td><td align=center>1</td></tr><tr><td align=center>m9</td><td align=center>1</td><td align=center>0</td><td align=center>0</td><td align=center>1</td><td align=center>x</td></tr><tr><td align=center>m10</td><td align=center>1</td><td align=center>0</td><td align=center>1</td><td align=center>0</td><td align=center>1</td></tr><tr><td align=center>m11</td><td align=center>1</td><td align=center>0</td><td align=center>1</td><td align=center>1</td><td align=center>1</td></tr><tr><td align=center>m12</td><td align=center>1</td><td align=center>1</td><td align=center>0</td><td align=center>0</td><td align=center>1</td></tr><tr><td align=center>m13</td><td align=center>1</td><td align=center>1</td><td align=center>0</td><td align=center>1</td><td align=center>0</td></tr><tr><td align=center>m14</td><td align=center>1</td><td align=center>1</td><td align=center>1</td><td align=center>0</td><td align=center>x</td></tr><tr><td align=center>m15</td><td align=center>1</td><td align=center>1</td><td align=center>1</td><td align=center>1</td><td align=center>1</td></tr></tbody></table><p>この真理値表から機械的に積和形の式を書くとめっちゃ長くなるが、論理変数の数が最も少ない最簡形まで簡単化すると下のようにめっちゃ短い2通りの論理式になる。</p><p>\(
\begin{align}
f(A,B,C,D) &amp;= B \overline{C} \overline{D} + A \overline{D} + A C\\<br>&amp;= B \overline{C} \overline{D} + A \overline{B} + A C
\end{align}<br>\)</p><p>論理式が簡単になると何が嬉しいのかというと、まず人間が読めるようになるというのがある。
文字数が減ると入力間違いが減る。</p><p>あと回路やプログラムに論理式を使うときも嬉しいと思う。
簡単化した式はそのぶん必要な論理演算の数が減っており、電子回路なら小型化できるし、プログラムなら冗長性を減らせる。</p><p>気をつけなければならないのが、この最簡形は空間的に最適だが時間的に最適とは限らないということだ。
計算に必要な論理ゲートの数を減らすのと引き換えに、論理ゲートの段数が増えることがある。
そうなると結果的に計算に必要な時間は増えてしまう。</p><h3 id=クワイン-マクラスキー法>クワイン・マクラスキー法</h3><p>そんな簡単化をする方法は色々あるが、その中でコンピュータで自動化しやすいのがクワイン・マクラスキー法である。
クワイン・マクラスキー法では<a href=https://ja.wikipedia.org/wiki/%E9%81%B8%E8%A8%80%E6%A8%99%E6%BA%96%E5%BD%A2>加法標準形</a>という形の論理式を最簡化する。
要するに上の式みたいにANDとNOTでできた項をORで繋いだ形のことである。</p><p>クワイン・マクラスキー法は以下のステップに分かれている。</p><ol><li>真理値表などを加法標準形に変換</li><li>主項(素項)を見つける<ol><li>項をハミング重みで分類</li><li>項をまとめる</li><li>くりかえす</li></ol></li><li>主項を組み合わせて最簡形にする</li></ol><p>自分は加法標準形への変換以外の部分を書いた。
以降コードとともに手順を書いていく。</p><h4 id=入出力の定義>入出力の定義</h4><p>最初に関数の形を決めておく。</p><pre><code class=language-d>enum Literal
{
    T, // Term
    N, // ¬Term
    X // Null
}

alias Conjunction = Literal[];
alias DNF = Conjunction[]; // Disjunctive normal form

DNF[] qm(DNF dnfin, size_t[] dontcare)
</code></pre><p>項はリテラルの配列として表す。
たとえば\(B \overline{C} \overline{D}\)なら<code>[X, T, N, N]</code>というふうになる。
配列の長さは変数の数であり、ばらばらの長さの配列が与えられることはないとする。</p><p>加法標準形の式は項の配列として表す。
つまり\(B \overline{C} \overline{D} + A \overline{D} + A C\)なら<code>[[X, T, N, N], [T, X, X, N], [T, X, T, X]]</code>となる。</p><p>リテラル、項、式をそれぞれ<code>Literal</code>、<code>Conjunction</code>、<code>DNF</code>として定義する。
クワイン・マクラスキー法の関数<code>qm</code>は、<code>DNF</code>とDon&rsquo;t careの項のインデックスを受取りそのすべての最簡形を<code>DNF[]</code>として返す。</p><p>簡単な動作確認としてユニットテストがついている。
もうなんかめんどくさいのでこのテストが通ったら完成とする。</p><pre><code class=language-d>unittest
{
    // https://ja.wikipedia.org/wiki/%E3%82%AF%E3%83%AF%E3%82%A4%E3%83%B3%E3%83%BB%E3%83%9E%E3%82%AF%E3%83%A9%E3%82%B9%E3%82%AD%E3%83%BC%E6%B3%95
    DNF input = () {
        with (Literal)
            return [// dfmt off
                [N, T, N, N],
                [T, N, N, N],
                [T, N, N, T],// Don't care
                [T, N, T, N],
                [T, T, N, N],
                [T, N, T, T],
                [T, T, T, N],// Don't care
                [T, T, T, T]
            ];
            // dfmt on
    }();
    DNF[] output = () {
        with (Literal)
            return // dfmt off
            [
                [[X, T, N, N], [T, X, X, N], [T, X, T, X]], // B¬C¬D + A¬D + AC
                [[X, T, N, N], [T, N, X, X], [T, X, T, X]] // B¬C¬D + A¬B + AC
            ];
            // dfmt on
    }();
    assert(qm(input, [2, 6]) == output);
}
</code></pre><h4 id=ハミング重み-ハミング距離-項のマージ>ハミング重み、ハミング距離、項のマージ</h4><p>ここで<code>qm</code>の実装に必要な関数を作っておく。
まずはハミング重み。
これは項の中の<code>T</code>の数を数える。</p><pre><code class=language-d>size_t hammingWeight(Conjunction a)
{
    import std.algorithm : filter, map, sum;

    return a.filter!(x =&gt; x == Literal.T)
        .map!(x =&gt; 1)
        .sum;
}

unittest
{
    with (Literal)
    {
        assert(hammingWeight([N, N, N]) == 0);
        assert(hammingWeight([N, N, T]) == 1);
        assert(hammingWeight([T, T, T]) == 3);
        assert(hammingWeight([X, N, T]) == 1);
    }
}
</code></pre><p>次にハミング距離。
2つの項の中で異なるリテラルの数を数える。</p><pre><code class=language-d>size_t hammingDistance(Conjunction a, Conjunction b)
{
    import std.algorithm : filter, map, sum;
    import std.range : zip;

    return zip(a, b).filter!(t =&gt; t[0] != t[1])
        .map!(x =&gt; 1)
        .sum;
}

unittest
{
    with (Literal)
    {
        assert(hammingDistance([T, T, T], [T, T, T]) == 0);
        assert(hammingDistance([N, N, N], [N, N, T]) == 1);
        assert(hammingDistance([T, N, T], [N, T, N]) == 3);
        assert(hammingDistance([T, N, X], [T, X, T]) == 2);
    }
}
</code></pre><p><code>hammingDistance(a, b) == 1</code>のとき、<code>a</code>、<code>b</code>は</p><p>\(
\begin{align}
X\cdot P + \overline{X}\cdot P &amp;= (X + \overline{X})\cdot P\\<br>&amp;= I\cdot P = P
\end{align}
\)</p><p>を用いてマージできる。</p><pre><code class=language-d>Conjunction merge(Conjunction a, Conjunction b)
{
    assert(hammingDistance(a, b) == 1);
    auto result = new Conjunction(a.length);
    foreach (i, ref l; result)
        if (a[i] == b[i])
        {
            l = a[i];
        }
        else
        {
            l = Literal.X;
        }
    return result;
}

unittest
{
    with (Literal)
    {
        assert(merge([T, T, T], [T, T, N]) == [T, T, X]);
        assert(merge([N, X, N], [N, X, T]) == [N, X, X]);
    }
}

</code></pre><h4 id=主項をみつける>主項をみつける</h4><p><code>qm</code>に戻って、いよいよアルゴリズムを書いていくが、
その前にクワイン・マクラスキー法がなぜクワイン・マクラスキー法というかをここで解説しておく。</p><p>まず最初にクワイン法というものがあった。
これはさっきの\(X\cdot P + \overline{X}\cdot P = P\)を適用できる項があるかをひたすら全部の組み合わせについて見ていく方法である。
アルゴリズムとしてはハミング距離が1になっている組を総当りで見つけてマージ、というのを繰り返していくことになると思う。</p><p>ここで、マクラスキー法によって総当りしなくてもハミング重みが1違う組だけを調べればいいということがわかった。
2つを組み合わせてクワイン・マクラスキー法というわけだ。</p><p>速度を考えずにとりあえず動くものを書くことを目標にしている今回はすべての項のハミング距離を調ベようと考えていたのだが、
そうしてしまうとマクラスキー要素がなくなってしまうのでちゃんと書く。</p><p>あと、ここでマージ元を覚えておく。
そのために<code>TaggedConjunction</code>というものを新たに作って、関数内部ではそれを使うようにしている。</p><pre><code class=language-d>DNF[] qm(DNF dnfin, size_t[] dontcare)
{

    import std.algorithm : sort, uniq, any, fold, equal, filter, map, sum;
    import std.range : array, iota, back, popBack, zip, empty;

    size_t size = dnfin[0].length;

    struct TaggedConjunction
    {
        bool flag;
        size_t[] mergedfrom;
        Conjunction conjunction;
    }

    TaggedConjunction[] merged;
    TaggedConjunction[] prime;

    foreach (i, c; dnfin)
        merged ~= TaggedConjunction(false, [i], c);
</code></pre><p>そして以下がマージ部。
マージされた項を<code>flag</code>で覚えておいて、マージされなかった項は主項として<code>prime</code>に追加しておく。
<code>foreach</code>が3重になっており、その中の<code>merge</code>でもループがあるので繰り返し1回ごとに4重ループが回る。
実用するためにはマクラスキー要素で総当りの量を減らせると嬉しいのがわかる。</p><pre><code class=language-d>    do
    {
        auto table = new TaggedConjunction[][](size + 1);
        foreach (c; merged)
            table[hammingWeight(c.conjunction)] ~= c;

        merged = [];

        foreach (i; 0 .. size)
            foreach (ref c1; table[i])
                foreach (ref c2; table[i + 1])
                    if (hammingDistance(c1.conjunction, c2.conjunction) == 1)
                    {
                        auto mergedfrom = (c1.mergedfrom ~ c2.mergedfrom).sort.uniq.array();
                        auto mergedconjunction = merge(c1.conjunction, c2.conjunction);
                        merged ~= TaggedConjunction(false, mergedfrom, mergedconjunction);

                        c1.flag = true;
                        c2.flag = true;
                    }

        foreach (t; table)
            foreach (c; t)
                if (c.flag == false &amp;&amp; !any!(x =&gt; x == c)(prime))
                    prime ~= c;
    }
    while (merged != []);
</code></pre><h4 id=最簡形を求める>最簡形を求める</h4><p>先程求められた主項<code>prime</code>の、入力の式を完全にカバーする組み合わせを見つける。
このためにマージ元を覚えておいてある。
入力の<strong>Don&rsquo;t care以外の</strong>すべての項がカバーされるように主項を選ぶ。
「Don&rsquo;t care以外の」というところをここに来るまで見落としていて大変なことになった。</p><p>あらかじめ絶対必要な項を見つけておいて総当りの量を減らしたり、
ペトリック法というアルゴリズムを使ったりするようだが気にせず総当り。
ペトリック法は日本語の情報が少ない。
そのうち調べてみたい。</p><pre><code class=language-d>    size_t min = size_t.max;
    DNF[] result;
    bool[] stack = [false];

    while (true)
    {
        if (stack.length &lt; prime.length)
        {
            stack ~= false;
        }
        else
        {
            bool isCovered = zip(stack, prime).map!(x =&gt; (x[0]) ? x[1].mergedfrom : [])
                .fold!((a, b) =&gt; a ~ b)
                .sort
                .uniq
                .filter!(n =&gt; !any!(d =&gt; d == n)(dontcare))
                .equal(iota(0, dnfin.length).filter!(n =&gt; !any!(d =&gt; d == n)(dontcare)));
            if (isCovered)
            {
                auto tmp = zip(stack, prime).filter!(x =&gt; x[0])
                    .map!(x =&gt; x[1].conjunction)
                    .array;
                size_t s = tmp.fold!((a, b) =&gt; a ~ b)
                    .map!(l =&gt; (l != Literal.X) ? 1 : 0)
                    .sum();
                if (s &lt; min)
                {
                    min = s;
                    result = [tmp];
                }
                else if (s == min)
                {
                    result ~= tmp;
                }
            }

            while (!stack.empty &amp;&amp; stack.back)
                stack.popBack();
            if (stack.empty)
                return result;
            stack.popBack();
            stack ~= true;
        }
    }
</code></pre><h4 id=完成>完成</h4><p>そういうわけでクワイン・マクラスキー法が実装できた。
動かしてみる。</p><pre><code class=language-console>$ time dmd -main -unittest qm.d &amp;&amp; ./qm 

real	0m1.040s
user	0m0.850s
sys	0m0.178s
</code></pre><p>ユニットテストをしているだけなので何も表示されなくてちょっとさみしい。
コンパイル時間も含めて1秒で計算が終わった。
こんな雑に書いても人間に比べれば一瞬で終わらせられるのがコンピューターのいいところだと思う。</p><h3 id=できたもの>できたもの</h3><p>全体はgistに上げた。</p><p><a href=https://gist.github.com/kotet/e0ba2b1e74705f5d9a170d2459589797>Quine-McCluskey algorithm</a></p><p>まだどう書けばいいのかはっきり思い浮かばないが、気力があったらHaskellでも書いてみたい。</p><h3 id=参考文献>参考文献</h3><p><a href=http://iss.ndl.go.jp/books/R100000002-I000001611921-00>ブール代数とその応用 (東海大学出版会): 1983</a></p></article><footer><h2><a href=/tags/dlang>#dlang</a>
Dで書くクワイン・マクラスキー法</h2><p><time>2018-07-01</time>
<a href=/tags/dlang>#dlang</a> <a href=/tags/tech>#tech</a> <a href=/tags/log>#log</a></p></footer><div class=ad-wrapper><ins class=adsbygoogle style=display:block data-ad-client=ca-pub-8443812672116269 data-ad-slot=2914874272 data-ad-format=horizontal data-full-width-responsive=true></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div></main><footer class=site></footer></body></html>