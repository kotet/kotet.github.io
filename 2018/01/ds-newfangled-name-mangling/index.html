<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=description content="D言語の短期的な設計目標の一つにCとのインターフェース能力があります。 その目標のために、Cの標準ライブラリへのアクセスを可能にし、CやC&#43;&#43;コンパイラが使うのと同じオブジェクトファイルフォーマットとシステムリンカを使うABI互換を提供しています。"><link rel=stylesheet href=https://blog.kotet.jp/sass/single.min.6dfdaa6c2e1289ce61fc60579a45b9a066807fb28892e759887da3d721cf8940.css><script defer src="//cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type=text/javascript></script><script type=text/x-mathjax-config>
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        displayMath: [['$$','$$']],
        processEscapes: true
      }
    });
</script><title>#dlang Dの新しい名前修飾【抄訳】 - Kotet&#39;s Personal Blog</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel=canonical href=https://blog.kotet.jp/2018/01/ds-newfangled-name-mangling/><link rel=icon href=/favicon.ico><meta name=twitter:card content=summary><meta name=og:title content="#dlang Dの新しい名前修飾【抄訳】 - Kotet's Personal Blog"><meta name=og:description content="D言語の短期的な設計目標の一つにCとのインターフェース能力があります。 その目標のために、Cの標準ライブラリへのアクセスを可能にし、CやC&#43;&#43;コンパイラが使うのと同じオブジェクトファイルフォーマットとシステムリンカを使うABI互換を提供しています。"><meta name=twitter:image content=https://blog.kotet.jp/assets/logo.png><meta name=twitter:url content=https://blog.kotet.jp/2018/01/ds-newfangled-name-mangling/><meta name=twitter:site content=@kotetttt><meta name=twitter:creator content=@kotetttt><meta name=generator content="Hugo 0.49"><script defer src="//www.googletagmanager.com/gtag/js?id=UA-88180620-1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-88180620-1');</script><script async src=//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script><script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"ca-pub-8443812672116269",enable_page_level_ads:true});</script></head><body><header class=site><nav><ul><li><a href=/about>ABOUT</a></li><li><a href=/products>PRODUCTS</a></li><li><a href=/tags>TAGS</a></li><li><a href=/index.xml>FEED</a></li></ul></nav><h1><a href=/>KOTET'S PERSONAL BLOG</a></h1></header><main><header><h2><a href=/tags/dlang>#dlang</a>
Dの新しい名前修飾【抄訳】</h2><p><time>2018-01-15</time>
<a href=/tags/dlang>#dlang</a> <a href=/tags/tech>#tech</a> <a href=/tags/translation>#translation</a> <a href=/tags/d_blog>#d_blog</a></p><aside><p>Table of Contents</p><nav id=TableOfContents><ul><li><ul><li><ul><li><a href=#シンボル名修飾とは何か>シンボル名修飾とは何か？</a></li><li><a href=#テンプレートシンボル>テンプレートシンボル</a></li><li><a href=#シンボル圧縮による解決>シンボル圧縮による解決</a></li><li><a href=#新しい修飾法は健全か>新しい修飾法は健全か？</a></li><li><a href=#影響>影響</a></li></ul></li></ul></li></ul></nav></aside></header><article><p>この記事は
<a href=https://dlang.org/blog/2017/12/20/ds-newfangled-name-mangling/>D’s Newfangled Name Mangling – The D Blog</a>
を自分用に翻訳したものを
<a href=http://dlang.org/blog/2017/06/16/life-in-the-fast-lane/#comment-1631>許可を得て</a>
公開するものである。</p><p>ソース中にコメントの形で原文を残している。
自分の能力が微妙に届かず誤字や誤訳などが多いと思うので、気になったら
<a href=https://github.com/kotet/blog.kotet.jp>Pull request</a>
を投げつけてくれると喜ぶ。</p><hr><p>Rainer SchuetzeはVisual StudioのD言語プラグイン、<a href=http://rainers.github.io/visuald/visuald/StartPage.html>Visual D</a>の作者でありメンテナーです。
最近、彼は<a href=https://dlang.org/changelog/2.077.0.html>DMD 2.077.0</a>でリリースされたDの新しい名前修飾アルゴリズムを実装しました。
この投稿では、何故それが必要で、どのように行われるのかを説明します。</p><hr><h3 id=シンボル名修飾とは何か>シンボル名修飾とは何か？</h3><p>Dはソースコードをオブジェクトファイルにコンパイルし、リンカを使いオブジェクトファイルを実行可能バイナリファイルにまとめるという分割コンパイルモデルを採用しています。
これによって以前にコンパイルされたオブジェクトファイルやライブラリを再利用し、ビルドプロセスの高速化ができます。
C/C++やFortranのような同じコンパイルモデルを持つ言語でも同じリンカが使われるため、異なる言語のオブジェクトファイルを直接組み合わせられます。</p><p>オブジェクトファイルのなかでは呼び出したりアクセスしたりするために定義された各関数とグローバル変数にシンボル名が割り当てられています。
リンカはそのシンボル名を利用する事で、シンボルに関する知識を持たずに同名の定義の参照をつなぎ合わせます。
たとえば、このCの関数宣言のシンボルは、</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-d data-lang=d>extern(C) const(char)* find(int ch, const(char)* str);</code></pre></div><p>Cがシンボル名として普通の名前 <code>find</code> を使うため（プラットフォームによってはシンボルの最初に<code>_</code>が付きます）、関数の引数や返値の型について何もリンカに伝えません。
後で引数の順番をこのとおり変えたとしても、</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-d data-lang=d>extern(C) const(char)* find(const(char)* str, int ch);</code></pre></div><p>更新と新しい宣言を使うすべてのソースファイルの再コンパイルは行われず、リンカはそのオブジェクトファイルを幸運なことにもくっつけてしまいます。
この場合、関数に渡されたキャラクタが文字列ポインタとして解釈され、逆も同じように解釈されてしまうため、たぶんプログラムはクラッシュします。</p><p>DやC++はこの問題を回避するためシンボル名に情報を追加します。
つまり、シンボルが定義されたスコープ、関数の引数や返り値の型をシンボル名にエンコードします。
リンカは相変わらずこの情報を解釈しませんが、オブジェクトファイルのビルドに使われる宣言が一致しない場合、リンクは未定義シンボルエラーで失敗します。
たとえば以下のDの関数宣言は</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-d data-lang=d>module test;

extern(D) const(char)* find(int ch, const(char)* str);</code></pre></div><p><code>_D4test4findFiPxaZPxa</code>というシンボル名になります。
<code>_D</code>はDのソースのシンボルから生成されたシンボルを識別するプレフィックス、<code>4test4find</code>は<code>test</code>モジュールの<code>find</code>が「完全修飾名」にエンコードされたもの、<code>FiPxaZPxa</code>は整数引数（<code>i</code>と呼ばれます）とCスタイルの文字列ポインタ型<code>Pxa</code>を単に繋げた引数の型のエンコーディングです。
<code>Z</code>で関数の引数リストを終わらせて、返り値の型が後に続き、それはCスタイル文字列ポインタの<code>Pxa</code>です。
一方、</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-d data-lang=d>extern(D) const(char)* find(const(char)* str, int ch);</code></pre></div><p>は引数の型が逆になっているところが異なる <code>_D4test4findFPxaiZPxa</code>にエンコードされます。
エンコーディングは型とスコープの表現をノーマライズし、最小限のソースコードよりも短いシンボルを提供します。
このエンコーディングが「名前修飾」と呼ばれます。</p><p><em>資料: <code>extern(C)</code>や<code>extern(D)</code>は<a href=https://dlang.org/spec/attribute.html#linkage>リンケージ属性</a>です。
Dにおいて関数が明示的なリンケージ属性なしで宣言される時、<code>extern(D)</code>がデフォルトになります。</em></p><p>Dでは<code>@safe</code>、<code>nothrow</code>、<code>pure</code>、<code>@nogc</code>のような関数の属性のいくつかはシンボル名へと修飾されます。
理屈の上ではパラメータ名、<a href=https://dlang.org/spec/attribute.html#UserDefinedAttribute>ユーザ定義属性</a>、<a href=https://dlang.org/spec/contracts.html>契約</a>を修飾に含めることもできますが、いまのところそれは過剰だと考えられています。</p><p>名前修飾が関数のバイナリインタフェース（引数がレジスタやスタックにどのように渡されるかなど）の不一致を検知したとしても、エラーはキャッチされないことに注意してください。
たとえば構造体、クラス、その他ユーザ定義型はその名前のみが修飾され、その定義の変更をリンカは検知しません。</p><p>シンボルの修飾名は<code>.mangleof</code>プロパティからコンパイル時に利用することもできます。
これはコンパイル時にシンボルの型リフレクションをするために活用されていました。
これは情報により速く、便利にアクセスできる新しい<a href=https://dlang.org/spec/traits.html><code>__traits</code></a>の導入により不要になりました。
たとえば、</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-d data-lang=d>__traits(getLinkage,symbol);</code></pre></div><p>または</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-d data-lang=d>__traits(getFunctionAttributes, symbol);</code></pre></div><p>従って、<code>.mangleof</code> の使用はデバッグ用途を除き推奨されません。</p><p>&ldquo;demangler（逆修飾器）&rdquo;で修飾プロセスを逆回しして、エンコードされたすべての情報をユーザが利用できる形にしたとしても、それは必ずしも正しいDのシンタックスになりません。
上で取り上げた最初の宣言は以下のように逆修飾されます。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-d data-lang=d>const(char)* test.find(int, const(char)*)</code></pre></div><p>モジュール名<code>test</code>が関数名に足されています。</p><h3 id=テンプレートシンボル>テンプレートシンボル</h3><p>上の2つの<code>find</code>の定義はDとC++両方に存在できるもののため、名前修飾以外にもリンク時にエラーを検出する方法がありますが、オーバーロードを表現する必要もあります。
そのため少なくとも同じスコープの識別子の異なるオーバーロードを識別するために必要な情報を含む必要があります。</p><p>これは通常引数の型ごとに異なる関数や変数の定義をインスタンス化するテンプレートのことを考えてみても明らかなことです。
Dでは、テンプレートのインスタンス化の情報はシンボルの修飾名に追加されます。</p><p>式テンプレートは、式の遅延評価を使うメタプログラミングの一般的な例です:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-d data-lang=d>module expr;

struct Mul(X,Y)

{

    X x;

    Y y;

}

struct Add(X,Y)

{

    X x;

    Y y;

}

auto mul(X,Y)(X x, Y y) { return Mul!(X,Y)(x, y); }

auto add(X,Y)(X x, Y y) { return Add!(X,Y)(x, y); }</code></pre></div><p>関数テンプレートはコンパイラによって<a href=https://dlang.org/spec/template.html#implicit_template_properties>冠名テンプレート</a>に書き下されます:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-d data-lang=d>template mul(X, Y)

{

    auto mul(X x, Y y) { return Mul!(X,Y)(x, y); }

}</code></pre></div><p>テンプレート名は修飾関数名<code>expr.mul!(X,Y).mul</code>の一部となり、auto返値型は推論され<code>Mul!(X,Y)</code>になります。
これによりシンボルは型<code>X</code>と<code>Y</code>を3回参照します。
このテンプレートを型<code>double</code>と<code>float</code>でインスタンス化したものの修飾名を逆修飾するとこのようになります。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-d data-lang=d>expr.Mul!(double,float) expr.mul!(double,float).mul(double,float)</code></pre></div><p>バージョン2.077以前のDMDの修飾プロセスは宣言の抽象構文木をたどり、遭遇したすべての型の修飾表現を出力します。
以下のような積み重ね操作を考えてみましょう。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-d data-lang=d>auto square(X)(X x) { return mul(x, x); }

auto len = square(&#34;var&#34;);

pragma(msg, len.square.mangleof);

// S4expr66__T3MulTS4expr16__T3MulTAyaTAyaZ3MulTS4expr16__T3MulTAyaTAyaZ3MulZ3Mul

pragma(msg, typeof(len).mangleof.length);

pragma(msg, len.square.mangleof.length);

pragma(msg, len.square.square.mangleof.length);

pragma(msg, len.square.square.square.mangleof.length);

pragma(msg, len.square.square.square.square.mangleof.length);

pragma(msg, len.square.square.square.square.square.mangleof.length);

pragma(msg, len.square.square.square.square.square.square.mangleof.length);</code></pre></div><p>DMD 2.076以前では、これは<code>28u, 78u, 179u, 381u, 785u, 1594u, 3212u</code>という、ソースコード内の式が線形にしか増えていないのにもかかわらず加速的に増える修飾シンボル名の長さを出力します。
これは<code>Mul!(Mul!(string, string), Mul!(string, string))</code>のような型が組み合わさり、それが参照されるたびに完全な表現を繰り返し修飾するために起こる現象です。</p><p>上の<code>square</code>の呼び出しを12個繋げたものを作るとシンボルの長さは207,114まで増加します。
さらに悪いことに、生成されるCOFF/64-bitのオブジェクトファイルは15MBを超えて大きくなりコンパイル時間は0.1秒から1分ほどに増加します。
この時間のほとんどがコンパイル時にのみ使われるコードの生成に費やされます。</p><p>テンプレート関数から返される<a href=http://www.digitalmars.com/articles/b79.html>ヴォルデモート型</a>は、<a href="https://issues.dlang.org/show_bug.cgi?id=15831">型名の一部に</a>テンプレート引数を含めた関数シグネチャをもつため似たような状態になる事があります。
これも例よりも少ないコードで劇的なビルド時間の増加を見せます。</p><h3 id=シンボル圧縮による解決>シンボル圧縮による解決</h3><p>2016年の初期に、これらの長いシンボルを短くするいくつかの試みがなされました。</p><ul><li>ある閾値を超えた時にシンボル名を切り詰め、代わりに完全なシンボルのチェックサムを追加する。
これは既に255文字以上のシンボルを受け付けないOMFオブジェクトファイルフォーマットのDigitalMars Cコンパイラツールチェインのためにシンボルを出力する際にMD5ハッシュを用いて行われています。
これの欠点はシンボルが逆修飾できなくなってしまい、リンカメッセージのシンボルが人間に理解できる名前に変換できなくなる事です。</li></ul><ul><li>シンボル名にバイナリ圧縮を適用する。
完全なシンボル名の一部を辞書として、名前のなかの繰り返しをエンコードするスタンダードなやりかたです。
これは通常の識別子セットに無い文字を使って位置と長さのペアをエンコードすることにより通常行われます。
さらに、これは既にDMDがシンボルをOMFの225文字制限に合わせようとする際に（MD5ハッシュを適用する前に）使われていますが、これにもディスアドバンテージがあります。
ASCIIの範囲を超えた文字を使うとき、これはD言語のシンボル文字列として許容されるUTF8でエンコードされた文字と干渉します。
また、コンソールがロケール特有のの文字エンコーディングと間違えてしまうことによってリンカの出力を壊してしまう可能性があります。
これを回避するためにシンボルにbase64のようなバイナリからASCIIへの変換をかけてしまうと実際のシンボル名がますますわかりづらくなります。</li></ul><ul><li><a href=https://dlang.org/spec/abi.html#name_mangling>修飾構文</a>を拡張して既にエンコードされたエンティティへの参照をできるようにする。
バイナリ圧縮と似ていますが、エンティティに構文組み込みの終端子があるので長さのエンコードが不要です。
最も重要なエンティティは型です。
これはここで説明する問題に影響するためC++が選んだ道です。
C++は名前修飾を標準化しておらず、コンパイラやプラットフォームが決めています。
GNU g++は<a href=https://itanium-cxx-abi.github.io/cxx-abi/abi.html#mangling>Itanium C++ ABI mangling</a>を使っており、これはC++における上の例や<a href="https://issues.dlang.org/show_bug.cgi?id=15831">ヴォルデモート問題</a>のようなコードに対してうまく動作します。
MicrosoftのVisual C++も繰り返し出現する型をエンコードできますが、引数リストの最初の10個の型までにエンコーディングを制限しているため非常に長い名前を生成します。</li></ul><p>Dのシンボルの修飾に後者の案を適用した上での最初の試みは残念な結果に終わりました。
結局、当時のそれらの実装は<a href=https://github.com/dlang/dmd/blob/master/src/dmd/dmangle.d>DMDフロントエンドの修飾器</a>の、キャッシュした修飾型名の表現を組み合わせてより複雑な型を作るために再利用しているという小さな特徴を見逃していました。
これによりキャッシュされた型名から繰り返しを探す事ができないでいました。</p><p>この時私は<a href=https://github.com/dlang/dmd/pull/5855>それらの抜け</a>を廃した修飾の実証バージョンを作り始めました。
初期の結果は<a href="https://issues.dlang.org/show_bug.cgi?id=15831#c7">期待できるもので</a>、私はシンボルの長さをさらに削減できないか探求しました:</p><ul><li>完全修飾名は常にパッケージやモジュールの名前を含み、識別子は修飾名に繰り返し現れる傾向があります。</li></ul><ul><li>修飾名は同じモジュールまたはパッケージから来ることが多いので、1エンティティにエンコードするといい結果をもたらします。</li></ul><p><a href=https://dlang.org/phobos/index.html>Phobosランタイムライブラリ</a>のユニットテストはテンプレートをヘビーに使うコードのシンボルをたくさん含むため、それをユニットテスト候補としました。
Windowsのビルドのマップファイルでは、計測時点で127,172のシンボルが見つかりました。
これが異なる修飾法での結果です:</p><table><thead><tr><th>後方参照</th><th>最大長</th><th>平均長</th></tr></thead><tbody><tr><td>何もなし</td><td>416133</td><td>369</td></tr><tr><td>型</td><td>2095</td><td>157</td></tr><tr><td>型+識別子</td><td>1263</td><td>128</td></tr><tr><td>型+識別子+修飾名</td><td>1114</td><td>117</td></tr></tbody></table><p>（これは現時点の実装で計測したもので、最終的な修飾法と一緒にはならないかもしれません。
後方参照型に特殊文字を使いましたが、これはいい考えではありませんでした。
Dの修飾はすべてのプラットフォームで同じであると仮定していましたが、いくつかのプラットフォームでその文字は特殊な意味を持っていました。）</p><p>DMDにおいて識別子と型の区別は、後者が修飾に従ってマージされるためかなり簡単です。
それでも修飾名とそれに関連したシンボルはさまざまな問題を生み出しました。
関数引数の<code>string</code>として与えられた完全修飾名と、テンプレート引数で指定された型から関数の修飾名を構築する<code>core.demangle</code>の<code>mangleFunc</code>です。
これを実行時用に実装するには完全な修飾機構とイントロスペクション機能のコピーが必要で、それは現実的ではありません。
上のPhobosの統計が示す限られた利益を考えた結果、修飾名のエンコードのアイデアは却下されました。</p><p>新しい修飾法についてまとめると:</p><ul><li>後方参照は文字列<code>Q</code>でエンコードされ、同じ識別子や型の元の出現箇所の相対位置が続きます。
これらの位置は最後の桁を小文字、それ以外の桁を大文字でエンコードするbase 26を参考にエンコードされます。
そうすることで、ほとんどの後方参照は2、3文字になり、4文字になることは稀です。
最後の桁だけ異なる形式にすることで次の文字を見ずに数値の終わりを識別できます。
これによって曖昧さがなくなります。
（Itanium C++ ABI修飾では、数字と文字を組み合わせて終端文字<code>_</code>を使うbase 36を使います。）</li></ul><ul><li>C++の修飾をエンコード可能なエンティティとして数えると修飾名が少し短くなりますが、修飾器がそれぞれの位置の動的リストを持ち続けなければならなくなります。
現在の逆修飾器は十分な大きさの出力バッファをアロケートするようにはできていません。</li></ul><ul><li>シンボルの再エンコードなしに<code>_D</code>プレフィックスを追加するために絶対位置ではなく相対位置が選ばれました。
プラットフォームによってはアンダースコアが多かったりしますが、相対位置なら関係ありません。</li></ul><ul><li>修飾構文は型と識別子が同じ場所にあるのを許容するため、逆修飾器はそれが後方参照であっても2つを区別する必要があります。
そのため参照位置のルックアップが逆修飾の際に必要となります。
識別子は常に数値から始まり、型は常に文字から始まります。</li></ul><ul><li>Using <code>Q</code> for back references grabs the last free letter used to encode types, but there is at least one type defined in the mangling grammar that is not supposed to appear in a mangling anyway (namely <code>TypeIdent</code>), so it can be resurrected if the necessity appears. <sup class=footnote-ref id=fnref:1><a href=#fn:1>1</a></sup></li></ul><p>たとえば、上の式テンプレート型は以下のように修飾されます。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-d data-lang=d>pragma(msg, len.square.mangleof);
// S4expr__T3MulTSQo__TQlTAyaTQeZQvTQtZQBb
//                ^^   ^^     ^^ ^^ ^^ ^^^ decode to:
//                |    |      |  |  |  |
//                |    |      |  |  |  +- 3Mul
//                |    |      |  |  +---- S4expr__T3MulTAyaTAyaZ3Mul
//                |    |      |  +------- 3Mul
//                |    |      +---------- Aya
//                |    +----------------- 3Mul
//                +---------------------- 4expr</code></pre></div><p>長さは後方参照を使わない時の78から39になっています。
結果の長さは23, 39, 57, 76, 95, 114, 133と線形に増えます。
<code>square</code>の呼び出しの12連鎖は207,114文字から247、つまり800分の1以下にまで小さくなります。</p><p>上で言及していた後方参照を使った修飾の<code>mangleFunc</code>の実装はどうなったのでしょうか。
完全修飾名は型（たとえば構造体テンプレートの引数として）を含んでいないはずですが、修飾名の識別子は関数型に再び現れることがあります。
これは逆修飾器を<a href=https://dconf.org/2017/talks/alexandrescu.pdf>“Design by Introspection” (DbI)</a>（Andrei Alexandrescuの作ったものです）を使って拡張することで解決されました。</p><ul><li><code>Demangle</code>構造体という、フックを提供する構造体をパラメータ化するテンプレートを作る。
<code>d
struct NoHooks {} // supports: static bool parseLName(ref Demangle); ...
private struct Demangle(Hooks = NoHooks)
{
Hooks hooks;
// ...
void parseLName()
{
static if(__traits(hasMember, Hooks, &quot;parseLName&quot;))
if (hooks.parseLName(this))
return;
// 普通のデコード...
}
}</code><br></li></ul><ul><li>頻出する識別子を適切な後方参照に置き換えるフックを作る。
<code>d
struct RemangleHooks
{
char[] result;
size_t[const(char)[]] idpos;
// ...
bool parseLName(ref Demangler!RemangleHooks d)
{
// これまでのresult[]をフラッシュする
if (d.front == 'Q')
{
// 後方参照を再エンコード...
}
else if (auto ppos = currentIdentifier in idpos)
{
// 後方参照を識別子 *ppos にエンコード
}
else
{
idpos[currentIdentifier] = currentPos;
}
return true;
}
}</code><br></li></ul><ul><li>修飾名と先の型（<code>core.demangle</code>にはデコードする能力があります）を組み合わせて、フックされた逆修飾器を実行します
<code>d
char[] mangleFunc(FuncType)(const(char)[] qualifiedName)
{
const(char)mangledQualifiedName = encodeLNames(qualifiedName);
const(char)mangled = mangledQualifiedName ~ FuncType.mangleof;
auto d = Demangle!RemangleHooks(mangled, null);
d.mute = true; // 逆修飾は出力されません
d.parseMangledName();
return d.hooks.result;
}</code></li></ul><h3 id=新しい修飾法は健全か>新しい修飾法は健全か？</h3><p>後方参照は既存の修飾法を拡張した修飾法でエンコードされます。
残念ながら、既存のものは曖昧さが<a href=https://issues.dlang.org/>Dのイシュートラッキングシステム</a>に報告されており、まだ見つかっていない問題もあるでしょう。
<code>core.demangle</code>の逆修飾器はPhobosのユニットテストの未修正のシンボルのうち3%ほどを受け付けず、15%ほどが部分的にしか逆修飾されませんでした。</p><p>修飾法の変更はツール（逆修飾器、デバッガ）の更新を必要とするので、既に複雑で脆弱な定義への追加の健全性を検証するのは大変です。
とにかく、それらを取り除くいい機会でした。</p><p>既存の定義の再調査が必要でした。
機械的に調査を行うために、ウェブサイトから得られる修飾の仕様を<a href=https://www.gnu.org/software/bison/>bisonパーサジェネレーター</a>が解釈できる文法に変換しました。
BisonはLALR(1)パーサテーブル、基本的には修飾されたシンボルをスキャンしつつ、文字とそのサクセサを見るだけで文字が前のエンティティのものか新しいエンティティの最初かを決定できるものを作ることができます。
文法の処理中に競合が報告された時は、より大きなコンテキストで解決できることもありますが、本当の問題や望ましくない複雑さのヒントになります。
手動パーサ制御フローを表す疑似トークンを追加することで競合を回避できます。</p><p><a href=https://gist.githubusercontent.com/rainers/6cdf73b48837defb9f88/raw/3db6a3c8e72222ccd6b22e8ae01c601bd585e9d8/dwebsite4.bison>このgist</a>は後方参照のないDの修飾スキームの文法です。
これはまだBisonで走らせるといくつか競合がありますが、そのうちの1つが本当の<a href=https://github.com/dlang/dmd/pull/6702>定義の曖昧さ</a>です。
後方参照を文法に追加しても<a href=https://gist.githubusercontent.com/rainers/6cdf73b48837defb9f88/raw/3db6a3c8e72222ccd6b22e8ae01c601bd585e9d8/backref6.bison>競合は発生しませんでした</a>。</p><p>加えて、<a href=https://github.com/dlang/druntime/blob/master/src/core/demangle.d><code>core.demangle</code></a>は曖昧さのあるものを除くすべてのシンボルで動作するよう修正されました。</p><h3 id=影響>影響</h3><p><code>std.traits</code>の実装のうちいくつかはリンケージの決定などのコンパイル時プロパティのintrospectのためにシンボルの修飾を利用していました。
これはシンプルになった逆修飾器を使って行われました。
後方参照の導入により、これらはシンプルなシンボル名を除き何もする必要がなくなりました。
<code>core.mangleFunc</code>を使った方法はうまくいきそうに見えますが、CTFEで逆修飾を実行する必要があるためコンパイルを顕著に遅くします。
幸運にも、修飾で得られるすべての情報をカバーする新しい<code>__traits</code>が追加されました。</p><p>ほとんどのユーザはオブジェクトファイルや実行ファイルのサイズが小さくなること以外の変化に気付くことはないでしょうが、新しい修飾法はリンカやデバッガなどの外部ツールにとっての破壊的変更になるかもしれません。
これらは動作はしますが、アップデートされるまでは逆修飾されたものの代わりに新しい修飾名を見ることになると思うので心の準備をしておいてください。</p><p>レビューをしてくれたMike Parker、Walter Bright、Steven Schveighofferに感謝します。</p><div class=footnotes><hr><ol><li id=fn:1>ここ意味が取れなかった
<a class=footnote-return href=#fnref:1><sup>[return]</sup></a></li></ol></div></article><footer><h2><a href=/tags/dlang>#dlang</a>
Dの新しい名前修飾【抄訳】</h2><p><time>2018-01-15</time>
<a href=/tags/dlang>#dlang</a> <a href=/tags/tech>#tech</a> <a href=/tags/translation>#translation</a> <a href=/tags/d_blog>#d_blog</a></p></footer><div class=ad-wrapper><ins class=adsbygoogle style=display:block data-ad-client=ca-pub-8443812672116269 data-ad-slot=2914874272 data-ad-format=horizontal data-full-width-responsive=true></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div></main><footer class=site></footer></body></html>