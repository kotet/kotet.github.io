<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=description content="Brainfuckはしばしば難解言語と呼ばれます。 Brainfuckをまともに書こうと思う人は少なく、 多くの場合既存のプログラムをコピペして"><link rel=stylesheet href=https://blog.kotet.jp/sass/single.min.a46209b7292a5337cb1ba441dd38238fbe3cc498d46e0bd08c757deccdc8f28f.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/d.min.js></script><script>hljs.configure({languages:[]})
hljs.initHighlightingOnLoad();</script><script defer src="//cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type=text/javascript></script><script type=text/x-mathjax-config>
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        displayMath: [['$$','$$']],
        processEscapes: true
      }
    });
</script><title>#dlang Brainfuckを出力する自作言語を作ってAtCoderに参加する - Kotet&#39;s Personal Blog</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel=canonical href=https://blog.kotet.jp/2019/dsl-for-brainfuck/><link rel=icon href=/favicon.ico><meta name=twitter:card content=summary><meta name=og:title content="#dlang Brainfuckを出力する自作言語を作ってAtCoderに参加する - Kotet's Personal Blog"><meta name=og:description content="Brainfuckはしばしば難解言語と呼ばれます。 Brainfuckをまともに書こうと思う人は少なく、 多くの場合既存のプログラムをコピペして"><meta name=twitter:image content=https://blog.kotet.jp/img/common/logo.png><meta name=twitter:url content=https://blog.kotet.jp/2019/dsl-for-brainfuck/><meta name=twitter:site content=@kotetttt><meta name=twitter:creator content=@kotetttt><meta name=generator content="Hugo 0.53"><script defer src="//www.googletagmanager.com/gtag/js?id=UA-88180620-1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-88180620-1');</script><script async src=//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script><script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"ca-pub-8443812672116269",enable_page_level_ads:true});</script></head><body><header class=site><nav><ul><li><a href=/about>ABOUT</a></li><li><a href=/products>PRODUCTS</a></li><li><a href=/tags>TAGS</a></li><li><a href=/index.xml>FEED</a></li></ul></nav><h1><a href=/>KOTET'S<br>PERSONAL<br>BLOG</a></h1></header><main><header><h2><a href=/tags/dlang>#dlang</a>
Brainfuckを出力する自作言語を作ってAtCoderに参加する</h2><p><time>2019-01-16</time>
<a href=/tags/dlang>#dlang</a> <a href=/tags/brainfuck>#brainfuck</a> <a href=/tags/tech>#tech</a></p><aside><p>Table of Contents</p><nav id=TableOfContents><ul><li><ul><li><ul><li><a href=#brainfuckを書くために>Brainfuckを書くために</a><ul><li><a href=#スタック>スタック</a></li><li><a href=#push-pop>Push &amp; Pop</a></li><li><a href=#加減乗算>加減乗算</a><ul><li><a href=#加算>加算</a></li><li><a href=#減算>減算</a></li><li><a href=#乗算>乗算</a></li></ul></li><li><a href=#比較>比較</a></li><li><a href=#if文>if文</a></li><li><a href=#while文>while文</a></li></ul></li><li><a href=#bflang-dsl-for-brainf-ck>bflang: DSL for brainf*ck</a></li><li><a href=#pegged-a-parsing-expression-grammar-peg-module-using-the-d-programming-language>Pegged: A Parsing Expression Grammar (PEG) module, using the D programming language.</a></li><li><a href=#問題を解いてみる>問題を解いてみる</a></li></ul></li></ul></li></ul></nav></aside></header><article><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/brainfuck.min.js></script><p>Brainfuckはしばしば難解言語と呼ばれます。
Brainfuckをまともに書こうと思う人は少なく、
多くの場合既存のプログラムをコピペしてきて楽しむだけで終わります。
Brainfuck派生言語とかもかなりの割合でHelloWorldしか実行してないんじゃないでしょうか。</p><p>そんな世の中でもBrainfuckを使い、それなりにクリエイティビティあふれるプログラムを書く人は存在します。
そういった人々と並ぶことはできなくても、
なにか<a href=https://atcoder.jp/>AtCoder</a>の問題を解いてみるくらいしたいなと思いました。
しかしBrainfuckを手書きできるほど<del>狂人</del>猛者ではないので、
なにか別の言語から変換したいです。</p><p>変換ツールはググればいっぱい出てきます。
<a href=https://github.com/shinh/elvm>ELVM</a>なんかはCコンパイラをまるごとBrainfuck化できるらしいので、
これらのツールを使えば一発でしょう。
しかし他人の作ったツールでBrainfuckと関係ない言語を書いているなら、
それは自分の実力でBrainfuckを書いたとは言えないんじゃないかと思ったんです。</p><p>そこでBrainfuckを出力するコンパイラを自作して、それでAtCoderの問題を解くことにしました。</p><h3 id=brainfuckを書くために>Brainfuckを書くために</h3><p>以下のスライドがわかりやすいです。
というかこのスライドがなかったら自分はこんなことやろうとは思いませんでした。</p><p><a href="https://www.slideshare.net/KMC_JP/brainfck?ref=http://localhost:1313/2019/dsl-for-brainfuck/">実用Brainf*ckプログラミング</a></p><p>スライドのなかで触れられているように、Brainfuckはスタックと相性が良い言語です。
スタックマシン向けのコンパイラの書き方はわかっているので、
スタック操作のBrainfuckコードを書くことができれば自動生成ができそうです。</p><h4 id=スタック>スタック</h4><p>今回生成するコードでは以下のようなデータ構造を使うことにしました。
0番地から9番地までにスタック構造を構築した図です。</p><table><thead><tr><th>インデックス</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th></tr></thead><tbody><tr><td>値</td><td>0</td><td>0</td><td>1</td><td>値</td><td>1</td><td>値</td><td>1</td><td>値</td><td>1</td><td>値</td><td>0</td><td>0</td></tr></tbody></table><p>スタック1要素あたり2バイトを使っています。
上のテーブルを元に説明します。
まず、偶数番目はスタック操作のために必要な情報です。
ここが1の場合「前に要素が存在する」という意味になります。
これによってスタックの先頭とスタックの根本を自由に行き来できるようになります。</p><p>以下、スタックの操作に必要な情報が入っている部分を操作部、要素の値が入っている部分を値部と呼びます。</p><p>0番地からスタックの先頭要素の値部に行くには以下のようにします。
0番地にある0番要素はスタックの根本を表すための番兵要素で、0番要素の値部（1番地）の値に意味はありません。</p><pre><code class=language-Brainfuck>&gt;&gt; 1番要素の操作部に移動
[&gt;&gt;] スタックの外側（上の例では10番地）まで移動。使っていない番地には0が入っていると仮定している
&lt; 行き過ぎたので戻る
</code></pre><p>逆にスタック先頭の値部から0番地に行くには以下のようにします。</p><pre><code class=language-Brainfuck>&lt; 操作部に移動
[&lt;&lt;] 0番地まで移動
</code></pre><p>とてもシンプルですね。
スタックの根本と先頭を自由に行き来できるようになったので、
スタックの根本より手前にスタックと干渉しない領域を作ることもできます。
つまり、生成するコードでは自由に伸びるスタックと固定長の変数領域の2つが利用できます。</p><p>ややこしくなるのでこの記事ではこれ以降出てきませんが、スタックを複数本作ることもできます。
以下は2本のスタックにそれぞれ<code>3</code>、<code>4,5</code>と値が入っている図です。</p><table><thead><tr><th>インデックス</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th></tr></thead><tbody><tr><td>値</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>3</td><td>4</td><td>0</td><td>1</td><td>0</td><td>5</td><td>0</td><td>0</td></tr></tbody></table><p>移動は以下のように<code>&gt;</code>や<code>&lt;</code>の数をスタックの本数分増やして行います。
今自分がどのスタックにいるか見失うと操作ができなくなるので、
操作を行った後は必ず0番スタックに戻ります。</p><pre><code class=language-Brainfuck>&gt;&gt;&gt;&gt;[&gt;&gt;&gt;&gt;]&lt;&lt; 0番スタックの根本(0番地)から先頭(6番地)に移動
&lt;&lt;[&lt;&lt;&lt;&lt;] 0番スタックの先頭から根本に移動
&gt; 1番スタックの根本に移動
&gt;&gt;&gt;&gt;[&gt;&gt;&gt;&gt;]&lt;&lt; 1番スタックの根本から先頭に移動
&lt;&lt;[&lt;&lt;&lt;&lt;] 0番スタックの先頭から根本に移動
&lt; 0番スタックの根本に戻る
</code></pre><h4 id=push-pop>Push &amp; Pop</h4><p>プログラムの実行中は0番スタックの先頭がホームポジションです。
スタックの先頭で以下の操作を行うとスタックに値を追加したり、取り出したりできます。</p><table><thead><tr><th>ポインタ</th><th></th><th></th><th></th><th></th><th></th><th>*</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>値</td><td>1</td><td>値</td><td>1</td><td>値</td><td>1</td><td>値</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><p>3を追加します。</p><pre><code class=language-Brainfuck>&gt;+ 操作部を1にする
&gt; 値部に移動
+++ 3をセット
</code></pre><table><thead><tr><th>ポインタ</th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th>*</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>値</td><td>1</td><td>値</td><td>1</td><td>値</td><td>1</td><td>値</td><td>1</td><td>3</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><p>削除します。</p><pre><code class=language-Brainfuck>[-] 値部をゼロにする
&lt;- 操作部をゼロにする
&lt; 前の要素の値部に移動
</code></pre><table><thead><tr><th>ポインタ</th><th></th><th></th><th></th><th></th><th></th><th>*</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>値</td><td>1</td><td>値</td><td>1</td><td>値</td><td>1</td><td>値</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><h4 id=加減乗算>加減乗算</h4><p>除算はまだ作ってないです……</p><h5 id=加算>加算</h5><p><code>4 + 5</code>を計算します。
アルゴリズムはこんな感じになります。</p><pre><code class=language-c>int add(int a, int b)
{
    while (a)
    {
        a--;
        b++;
    }
    return b;
}
</code></pre><table><thead><tr><th>ポインタ</th><th></th><th></th><th></th><th>*</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>値</td><td>1</td><td>4</td><td>1</td><td>5</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><pre><code class=language-Brainfuck>[&lt;&lt;+&gt;&gt;-] 前の要素に先頭の値を足す
&lt;-&lt;スタックを1戻す
</code></pre><table><thead><tr><th>ポインタ</th><th></th><th>*</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>値</td><td>1</td><td>9</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><h5 id=減算>減算</h5><p><code>5 - 2</code>を計算します。
基本は加算と同じです。</p><table><thead><tr><th>ポインタ</th><th></th><th></th><th></th><th>*</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>値</td><td>1</td><td>5</td><td>1</td><td>2</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><pre><code class=language-Brainfuck>[&lt;&lt;-&gt;&gt;-]
&lt;-&lt;
</code></pre><table><thead><tr><th>ポインタ</th><th></th><th>*</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>値</td><td>1</td><td>3</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><h5 id=乗算>乗算</h5><p><code>3 * 2</code>を計算します。
スタックの先頭よりも大きい番地を作業領域に使います。
<a href="https://fatiherikli.github.io/brainfuck-visualizer/#Kz4rKys+Kz4rKwo8PFsKICAgID4+Wz4rPis8PC1dCiAgICA+WzwrPi1dCiAgICA8PDwtCl0KPj4+Pls8PDw8Kz4+Pj4tXQo8PFstXTwtPA==">ビジュアライザで動作を見る</a>
とカチャカチャ動いて楽しい。</p><p>Cで同じことをするとこんな感じになります。</p><pre><code class=language-c>int mul(int a,int b)
{
    int c = 0;
    int d = 0;
    while(a){
        a--;
        while(b)
        {
            b--;
            c++;
            d++;
        }
        while(c)
        {
            c--;
            b++;
        }
    }
    while(d)
    {
        d--;
        a++;
    }
    return a;
}
</code></pre><table><thead><tr><th>ポインタ</th><th></th><th></th><th></th><th>*</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>値</td><td>1</td><td>3</td><td>1</td><td>2</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><pre><code class=language-Brainfuck>&lt;&lt;[
    &gt;&gt;[&gt;+&gt;+&lt;&lt;-] 先頭の値を2つの作業領域に移動
    &gt;[&lt;+&gt;-] 1つめだけ書き戻す
    &lt;&lt;&lt;- カウンタ
]
&gt;&gt;&gt;&gt;[&lt;&lt;&lt;&lt;+&gt;&gt;&gt;&gt;-] 2つ目の作業領域に結果が入っているので移動させる
&lt;&lt;[-]&lt;-&lt; 先頭の要素を消去
</code></pre><table><thead><tr><th>ポインタ</th><th></th><th>*</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>値</td><td>1</td><td>6</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><h4 id=比較>比較</h4><p><code>==</code>しか作ってないです。
スタックの先頭2要素を取り出して、値が同じなら1をPush、違えば0をPushという機能を持ちます。</p><pre><code class=language-Brainfuck>[&lt;&lt;-&gt;&gt;-]&lt;-&lt; 減算
&gt;+ フラグをセット
&lt;[&gt;-&lt;[-]] 差がゼロでない=違う時はフラグをリセットしてゼロにする
&gt;[&lt;+&gt;-]&lt; フラグが立っている=同じ時は1にする
</code></pre><h4 id=if文>if文</h4><pre><code class=language-Brainfuck>ここで条件式を評価しスタックにPushする
[
    if文の中身。先頭要素をPopしてしまわないように気をつける
[-]] if文終了。スタックの値をゼロにすることで1回でループを抜ける
&lt;-&lt; スタックを縮める
</code></pre><h4 id=while文>while文</h4><p>Brainfuckにデフォルトで付属している唯一の制御構文です。
言語機能として組み込まれているだけあって楽にかけます。
条件式の評価をするコードが2箇所に現れます。</p><pre><code class=language-Brainfuck>ここで条件式を評価しスタックにPushする
[
    [-]&lt;-&lt; スタックから条件式の結果をPop
    while文の中身
    ここで条件式を評価しスタックにPushする
]
&lt;-&lt; スタックを縮める
</code></pre><h3 id=bflang-dsl-for-brainf-ck>bflang: DSL for brainf*ck</h3><p>上のように独立した「部品」をたくさん作ることができたので、
あとはそれを適宜呼び出すコンパイラを作れば完成です。
というわけで完成したものがこちらになります。</p><p><a href=https://github.com/kotet/bflang>kotet/bflang: DSL for brainf*ck</a></p><p>完成と言ってもAtCoderのABCのA問題がなんとか解ける程度の機能しかありません。
まず文字列がないのがつらい……</p><p>しかしともかくプログラミングのようなことができる程度の機能があるので、コードを書いてみます。
以下は連続で<code>Y</code>と入力された回数を出力するプログラムです。</p><pre><code>n = 0;
while (getc() == 'Y')
{
    n = n + 1;
}
putc(n + '0');
</code></pre><p>そして以下が出力されるコードです。
最適化を全くしていないのでかなり非効率なコードになっています。</p><pre><code class=language-Brainfuck>&gt;
&gt;&gt;
&gt;+&gt;
&lt;[&lt;&lt;]&lt;&lt;[-]&gt;&gt;&gt;&gt;[&gt;&gt;]&lt;[&lt;[&lt;&lt;]&lt;&lt;+&gt;&gt;&gt;&gt;[&gt;&gt;]&lt;-]&lt;-&lt;
&gt;+&gt;,
&gt;+&gt;&gt;++++++++[&lt;+++++++++++&gt;-]&lt;+
[&lt;&lt;-&gt;&gt;-]&lt;-&lt;&gt;+&lt;[[-]&gt;-&lt;]&gt;[-&lt;+&gt;]&lt;
[[-]&lt;-&lt;
&gt;+&gt;&lt;[&lt;&lt;]&lt;&lt;[&gt;&gt;&gt;&gt;[&gt;&gt;]&lt;+&lt;[&lt;&lt;]&lt;&lt;-]&gt;&gt;&gt;&gt;[&gt;&gt;]&lt;[&gt;+&gt;+&lt;&lt;-]&gt;[&lt;+&gt;-]+&gt;&lt;[&lt;&lt;]&lt;&lt;[-]&gt;&gt;&gt;&gt;[&gt;&gt;]&lt;[&lt;[&lt;&lt;]&lt;&lt;+&gt;&gt;&gt;&gt;[&gt;&gt;]&lt;-]&lt;-&lt;
&gt;+&gt;+
[&lt;&lt;+&gt;&gt;-]&lt;-&lt;
&lt;[&lt;&lt;]&lt;&lt;[-]&gt;&gt;&gt;&gt;[&gt;&gt;]&lt;[&lt;[&lt;&lt;]&lt;&lt;+&gt;&gt;&gt;&gt;[&gt;&gt;]&lt;-]&lt;-&lt;
&gt;+&gt;,
&gt;+&gt;&gt;++++++++[&lt;+++++++++++&gt;-]&lt;+
[&lt;&lt;-&gt;&gt;-]&lt;-&lt;&gt;+&lt;[[-]&gt;-&lt;]&gt;[-&lt;+&gt;]&lt;
][-]&lt;-&lt;
&gt;+&gt;&lt;[&lt;&lt;]&lt;&lt;[&gt;&gt;&gt;&gt;[&gt;&gt;]&lt;+&lt;[&lt;&lt;]&lt;&lt;-]&gt;&gt;&gt;&gt;[&gt;&gt;]&lt;[&gt;+&gt;+&lt;&lt;-]&gt;[&lt;+&gt;-]+&gt;&lt;[&lt;&lt;]&lt;&lt;[-]&gt;&gt;&gt;&gt;[&gt;&gt;]&lt;[&lt;[&lt;&lt;]&lt;&lt;+&gt;&gt;&gt;&gt;[&gt;&gt;]&lt;-]&lt;-&lt;
&gt;+&gt;&gt;++++++[&lt;++++++++&gt;-]&lt;
[&lt;&lt;+&gt;&gt;-]&lt;-&lt;
.[-]&lt;-&lt;
</code></pre><h3 id=pegged-a-parsing-expression-grammar-peg-module-using-the-d-programming-language>Pegged: A Parsing Expression Grammar (PEG) module, using the D programming language.</h3><p>このコンパイラをつくるにあたって、Peggedというパーサジェネレータを使いました。
Cコンパイラを作った時は手書きパーサだったので、初めてのパーサジェネレータということになります。</p><p>このように構文をDのソースコードに直接書くと、それを元にしたパーサが使えるようになります。</p><pre><code class=language-d>import pegged.grammar;

mixin(grammar(`
Arithmetic:
    Term     &lt; Factor (Add / Sub)*
    Add      &lt; &quot;+&quot; Factor
    Sub      &lt; &quot;-&quot; Factor
    Factor   &lt; Primary (Mul / Div)*
    Mul      &lt; &quot;*&quot; Primary
    Div      &lt; &quot;/&quot; Primary
    Primary  &lt; Parens / Neg / Pos / Number / Variable
    Parens   &lt; &quot;(&quot; Term &quot;)&quot;
    Neg      &lt; &quot;-&quot; Primary
    Pos      &lt; &quot;+&quot; Primary
    Number   &lt; ~([0-9]+)

    Variable &lt;- identifier
`));
</code></pre><p>渡された構文の文字列をコンパイル時に解析して、コンパイル時に生成したコードを使います。
やっぱりライブラリとして整備されたパーサは便利でした。
<code>writeln</code>するだけで構文木全体がわかりやすく出力される機能には助けられた……</p><h3 id=問題を解いてみる>問題を解いてみる</h3><p>そういうわけでできたコンパイラを使って問題を1問解いてみました。</p><p><a href=https://atcoder.jp/contests/abc115/submissions/4023935>提出 #4023935 - AtCoder Beginner Contest 115</a></p><p>計算量とか一切気にしないでとりあえず動くことだけを目標に作った割には実行時間が短いです。
高速なBrainfuck処理系の作者に感謝。</p><p>文字列とか除算とか多倍長整数とか欲しい機能はいっぱいありますが、
気力が尽きてきたので生成されたコードの動きをビジュアライザで眺めて余生を過ごそうと思います。</p></article><footer><h2><a href=/tags/dlang>#dlang</a>
Brainfuckを出力する自作言語を作ってAtCoderに参加する</h2><p><time>2019-01-16</time>
<a href=/tags/dlang>#dlang</a> <a href=/tags/brainfuck>#brainfuck</a> <a href=/tags/tech>#tech</a></p></footer><div class=ad-wrapper><ins class=adsbygoogle style=display:block data-ad-client=ca-pub-8443812672116269 data-ad-slot=2914874272 data-ad-format=horizontal data-full-width-responsive=true></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div></main><footer class=site></footer></body></html>